// Generated by CoffeeScript 1.10.0
(function() {
  var aliasName, aliasing, arrEquals, funcForArgs, getObjectFromPath, isTree, method, methodName, parent, preferJSUtils, prototyping, ref, ref1, set, setName,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  window.DEBUG = true;

  window.JSUtils = {};


  /**
   * A class that executes asynchronous functions in an order.
   *
   * @example
   * `var seq = new Sequence([
   *     {
   *      func: () ->
   *          return true
   *      scope: someObject
   *      params: [1,2,3]
   *     }
   *     {
   *      func: () ->
   *          return new JSUtils.Sequence(...)
   *      scope: someObject
   *      params: (prevRes, presFunc, prevParams, idx) ->
   *          return [...]
   *     }
   *     [
   *      () -> return true,
   *      someObject,
   *      [1,2,3]
   *     ]
   * ])`
   *
   * Each asynchronous function MUST return an object that implements a `done()` method!
   *
   * This `done()` method takes 1 callback function as parameter (not like jQuery which can take multiple and arrays)! If parameters are to be passed to the callback, take care of it yourself (closuring?!).
   * When using `done()` callbacks in that asynchronous function those callbacks MUST be synchronous to make sure the order remains correct.
   *
   * @class Sequence
   * @extends Object
   * @constructor
   * @param data {Array}
   * Each element of that array is either an object like `{func: ..., scope: ..., params: ...}` and an array with the same values in that order.
   * For each element applies:
   * 'func' (or the 1st array element) is the function being executed.
   * 'scope' (or the 2nd element) is an object that serves as `this` in 'func'.
   * 'params' (or the 3rd element) is either
   * an array of parameters being passed to 'func'
   * or a function that creates such an array. In that case that function must have the form:
   * `(resultOfPreviouslyExecutedFunction, parametersOfPreviousCallback, previouslyExecutedFunction, scopeOfPreviouslyExecutedFunction, parametersOfPreviouslyExecutedFunction, indexInExecutionList) ->
   *     params = [...do stuff...]
   *     return params`
   * See the example or the static `test()` method for details.
   * @param start {Boolean}
   * Optional. Default is `true`. If it's `!== true` the Sequence will not start automatically. The `start()` method can be used to start it whenever.
  *
   */

  JSUtils.Sequence = (function() {
    Sequence.PARAM_MODES = {
      CONTEXT: "CONTEXT",
      IMPLICIT: "IMPLICIT",
      EXPLICIT: "EXPLICIT"
    };


    /**
    * This method does the same as window.setTimeout() but makes it useable by JSUtils.Sequence. It also takes an additional (optional) scope parameter.
    * Basically window.setTimeout() is used in order to delay a whole Sequence.
    *
    * The mechanism is lik so:
    * An empty Sequence is created and returned (after it returns the `done()` callback is added by the Sequence itself).
    * The empty Sequence is delayed by 'delay' (with the help of window.setTimeout()) and when before it starts the passed function 'func', 'scope', and all 'params' passed to the Sequence.
    * @static
    * @method setTimeout
    * @param {Function|String} func
    * This parameter is either a function or a code string.
    * @param {Integer} delay
    * @param {Function} scope
    * @param {mixed} param1
    * @param {mixed} param2
    * @param ...
    *
     */

    function Sequence(data, start, stopOnError) {
      if (data == null) {
        data = [];
      }
      if (start == null) {
        start = true;
      }
      if (stopOnError == null) {
        stopOnError = true;
      }
      this.data = data;
      this.idx = 0;
      this.stopOnError = stopOnError;
      this._doneCallbacks = [];
      this._startCallback = null;
      this._endCallback = null;
      this._errorCallback = null;
      this._isDone = false;
      this._isStopped = false;
      this._parameterMode = this.constructor.PARAM_MODES.EXPLICIT;
      if (start === true) {
        this.start();
      }
    }


    /**
    * This method starts the Sequence in case it has been created with `false` as start parameter.
    * @method start
    * @param newData {Array}
    * Optional. If an array is given it will replace the possibly previously set data.
    * @return This istance. {Sequence}
    * @chainable
    *
     */

    Sequence.prototype.start = function(newData) {
      if (newData instanceof Array) {
        this.data = newData;
      }
      if (typeof this._startCallback === "function") {
        this._startCallback();
      }
      this._invokeNextFunction();
      return this;
    };

    Sequence.prototype._createParamListFromContext = function(func, context) {
      var argName, len1, m, paramList, temp;
      if (!(context instanceof Array)) {
        paramList = func.toString().split(/[()]/g).second.split(/\s*,\s*/g);
        temp = [];
        for (m = 0, len1 = paramList.length; m < len1; m++) {
          argName = paramList[m];
          temp.push(context[argName]);
        }
        return temp;
      }
      return context.slice(0);
    };


    /**
    * This method invokes the next function in the list.
    * @protected
    * @method _invokeNextFunction
    * @param previousReult {mixed}
    * The result the previously executed function returned or `null`.
    * @param args... {mixed}
    * These are the arguments passed to the callback itself.
    * @return This istance. {Sequence}
    * @chainable
    *
     */

    Sequence.prototype._invokeNextFunction = function() {
      var CLASS, args, d, data, error, error1, func, newParams, params, ref, ref1, res, scope, self;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this._isStopped) {
        return this;
      }
      data = this.data[this.idx];
      if (data != null) {
        if (data instanceof Array) {
          func = data[0];
          scope = data[1];
          params = data[2];
        } else {
          func = data.func;
          scope = data.scope;
          params = data.params;
        }
        if (func != null) {
          CLASS = this.constructor;
          self = this;
          if (params instanceof Array && params.length > 0) {
            this._parameterMode = CLASS.PARAM_MODES.EXPLICIT;
          }
          if (this._parameterMode === CLASS.PARAM_MODES.CONTEXT) {
            newParams = this._createParamListFromContext(func, args[0].context);
          } else if (this._parameterMode === CLASS.PARAM_MODES.EXPLICIT) {
            newParams = params;
          } else if (this._parameterMode === CLASS.PARAM_MODES.IMPLICIT) {
            newParams = args;
          }
          if (params instanceof Function) {
            d = this.data[this.idx - 1];
            newParams = params(args, {
              func: (d != null ? d.func : void 0) || (d != null ? d[0] : void 0),
              scope: (d != null ? d.scope : void 0) || (d != null ? d[1] : void 0) || null,
              params: (d != null ? (ref = d.params) != null ? ref.slice(0) : void 0 : void 0) || (d != null ? (ref1 = d[2]) != null ? ref1.slice(0) : void 0 : void 0) || []
            }, this.idx);
          }
          try {
            res = func.apply(scope || window, newParams);
          } catch (error1) {
            error = error1;
            res = null;
            console.error("=================================================================");
            console.error("JSUtils.Sequence::_invokeNextFunction: Given function (at index " + this.idx + ") threw an Error!");
            console.warn("Here is the data:", data);
            console.warn("Here is the error:", error);
            console.error("=================================================================");
            if (this.stopOnError) {
              this.interrupt();
              if (typeof this._errorCallback === "function") {
                this._errorCallback(error);
              }
            }
          }
          if (((res != null ? res.done : void 0) != null) && ((res != null ? res.context : void 0) != null)) {
            res.done.done(function() {
              self.idx++;
              self._parameterMode = CLASS.PARAM_MODES.CONTEXT;
              return self._invokeNextFunction(res);
            });
          } else if ((res != null ? res.done : void 0) != null) {
            res.done(function() {
              self.idx++;
              self._parameterMode = CLASS.PARAM_MODES.IMPLICIT;
              return self._invokeNextFunction.apply(self, slice.call(arguments).concat([res]));
            });
          } else if (res != null ? res.context : void 0) {
            this.idx++;
            this._parameterMode = CLASS.PARAM_MODES.CONTEXT;
            this._invokeNextFunction(res);
          } else {
            this.idx++;
            this._parameterMode = CLASS.PARAM_MODES.IMPLICIT;
            this._invokeNextFunction(res);
          }
        }
      } else {
        this.lastResult = args[0];
        if (this._parameterMode === this.constructor.PARAM_MODES.CONTEXT) {
          this.lastResult = this.lastResult.context;
        }
        if (typeof this._endCallback === "function") {
          this._endCallback();
        }
        this._execDoneCallbacks();
      }
      return this;
    };


    /**
    * This method is called when the Sequence has executed all of its functions. It will then start executing all callbacks that previously have been added via `done()` (in the order they were added). No callback receives any parameters.
    * @protected
    * @method _execDoneCallbacks
    * @return This istance. {Sequence}
    * @chainable
    *
     */

    Sequence.prototype._execDoneCallbacks = function() {
      var cb, len1, m, ref;
      this._isDone = true;
      ref = this._doneCallbacks;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        cb = ref[m];
        cb();
      }
      return this;
    };

    Sequence.prototype.stop = function(execCallbacks) {
      if (execCallbacks == null) {
        execCallbacks = true;
      }
      this._isStopped = true;
      if (execCallbacks) {
        if (typeof this._endCallback === "function") {
          this._endCallback();
        }
        this._execDoneCallbacks();
      }
      return this;
    };

    Sequence.prototype.interrupt = function() {
      return this.stop(false);
    };

    Sequence.prototype.resume = function() {
      this._isStopped = false;
      this._invokeNextFunction();
      return this;
    };


    /**
    * Callback that gets called before the queue is being processed.
    * @method onStart
    *
     */

    Sequence.prototype.onStart = function() {
      var args, callback, context;
      callback = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof callback === "function") {
        this._startCallback = function() {
          return callback.apply(context, args);
        };
      }
      return this;
    };


    /**
    * Callback that gets called after the queue is processed but before the done callbacks are triggered.
    * @method onEnd
    *
     */

    Sequence.prototype.onEnd = function() {
      var args, callback, context;
      callback = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof callback === "function") {
        this._endCallback = function() {
          return callback.apply(context, args);
        };
      }
      return this;
    };

    Sequence.prototype.onError = function() {
      var args, callback, context;
      callback = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof callback === "function") {
        this._errorCallback = function(error) {
          return callback.apply(context, [error].concat(args));
        };
      }
      return this;
    };


    /**
    * This method adds a callback that will be executed after all functions have returned.
    * @method done
    * @param callback {Function}
    * A function (without parameters).
    * @param context {Object}
    * @param args... {Function}
    * Arguments to be passed to the callback function.
    * @return This istance. {Sequence}
    * @chainable
    *
     */

    Sequence.prototype.done = function() {
      var args, callback, context, self;
      callback = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof callback === "function") {
        self = this;
        if (!this._isDone) {
          this._doneCallbacks.push(function() {
            return callback.apply(context, args.concat([self.lastResult]));
          });
        } else {
          callback.apply(context, args.concat([self.lastResult]));
        }
      }
      return this;
    };

    Sequence.prototype.then = Sequence.prototype.done;


    /**
    * This method returns the progress of the Sequence in [0,1].
    * @method getProgress
    * @return progress {Number}
    *
     */

    Sequence.prototype.progress = function() {
      return this.idx / this.data.length;
    };


    /**
    * @method while
    * @return {Sequence}
    * @chainable
    *
     */

    Sequence.prototype["while"] = function(startFunc, endFunc, context, args) {
      this.onStart(startFunc, context, args);
      this.onEnd(endFunc, context, args);
      return this;
    };

    return Sequence;

  })();


  /**
  * A class that starts executing asynchronous functions and waits for them to finish.
  *
  * @example
  * `var barrier = new Barrier([
  *     {
  *      func: () ->
  *          return true
  *      scope: someObject
  *      params: [1,2,3]
  *     }
  *     {
  *      func: () ->
  *          return new JSUtils.Sequence(...)
  *      scope: someObject
  *     [
  *      () -> return true,
  *      someObject,
  *      [1,2,3]
  *     ]
  * ])`
  *
  * Each asynchronous function MUST return an object that implements a `done()` method!
  *
  * This `done()` method takes 1 callback function as parameter (not like jQuery which can take multiple and arrays)! If parameters are to be passed to the callback, take care of it yourself (closuring?!).
  * When using `done()` callbacks in that asynchronous function those callbacks MUST be synchronous to make sure the order remains correct.
  *
  * @class Barrier
  * @extends Object
  * @constructor
  * @param data {Array}
  * Each element of that array is either an object like `{func: ..., scope: ..., params: ...}` and an array with the same values in that order.
  * For each element applies:
  * 'func' (or the 1st array element) is the function being executed.
  * 'scope' (or the 2nd element) is an object that serves as `this` in 'func'.
  * 'params' (or the 3rd element) is an array of parameters being passed to 'func'
  * or a function that creates such an array. In that case that function must have the form:
  * @param start {Boolean}
  * Optional. Default is `true`. If it's `!== true` the Sequence will not start automatically. The `start()` method can be used to start it whenever.
  *
   */

  JSUtils.Barrier = (function() {
    Barrier.forArray = function(array, callback, start) {
      var data, elem, index, len1, m;
      if (array == null) {
        array = [];
      }
      if (start == null) {
        start = true;
      }
      data = [];
      for (index = m = 0, len1 = array.length; m < len1; index = ++m) {
        elem = array[index];
        data.push({
          func: (function(elem, index) {
            return function() {
              return callback(elem, index);
            };
          })(elem, index)
        });
      }
      return new JSUtils.Barrier(data, start);
    };

    function Barrier(data, start) {
      if (data == null) {
        data = [];
      }
      if (start == null) {
        start = true;
      }
      this.data = data;
      this.remainingThreads = data.length;
      this.funcResults = [];
      this._doneCallbacks = [];
      this._startCallback = null;
      this._endCallback = null;
      this._endAllCallback = null;
      this._isDone = false;
      this._isStopped = false;
      this._sequences = [];
      if (start === true) {
        this.start();
      }
    }


    /**
    * This method starts the Barrier in case it has been created with `false` as start parameter.
    * @method start
    * @param newData {Array}
    * Optional. If an array is given it will replace the possibly previously set data.
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype.start = function(newData) {
      var d, idx, len1, m, ref;
      if (newData instanceof Array) {
        this.data = newData;
        this.remainingThreads = newData.length;
      }
      if (typeof this._startCallback === "function") {
        this._startCallback();
      }
      if (this.remainingThreads > 0) {
        ref = this.data;
        for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
          d = ref[idx];
          if (d != null) {
            this._invokeNextFunction(d, idx);
          }
        }
      } else {
        this._funcDone();
      }
      return this;
    };


    /**
    * This method invokes the next function in the list.
    * @protected
    * @method _invokeNextFunction
    * @param data {Object|Array}
    * Function data (same structure as in JSUtils.Sequence)
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype._invokeNextFunction = function(data, idx) {
      var func, params, scope;
      func = data.func || data[0];
      scope = data.scope || data[1];
      params = data.params || data[2];
      this._sequences.push(new JSUtils.Sequence([
        {
          func: function() {
            var error, error1;
            try {
              return func.apply(scope, params);
            } catch (error1) {
              error = error1;
              return error;
            }
          }
        }, {
          func: function(prevResOrResponse) {
            this.funcResults[idx] = prevResOrResponse;
            this._funcDone();
            return this;
          },
          scope: this
        }
      ]));
      return this;
    };

    Barrier.prototype._funcDone = function() {
      if (--this.remainingThreads <= 0) {
        this._isDone = true;
        if (typeof this._endCallback === "function") {
          this._endCallback();
        }
        this._execDoneCallbacks();
        if (typeof this._endAllCallback === "function") {
          this._endAllCallback();
        }
      }
      return this;
    };


    /**
    * This method adds a callback that will be executed after all functions have returned.
    * @method done
    * @param callback {Function}
    * A function (without parameters).
    * @param context {Object}
    * @param args... {Function}
    * Arguments to be passed to the callback function.
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype.done = function() {
      var args, callback, context, self;
      callback = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof callback === "function") {
        self = this;
        if (!this._isDone) {
          this._doneCallbacks.push(function() {
            return callback.apply(context, args.concat([self.funcResults]));
          });
        } else {
          callback.apply(context, args.concat([self.funcResults]));
        }
      }
      return this;
    };

    Barrier.prototype.then = Barrier.prototype.done;


    /**
    * This method returns the progress (how many async function have already reached the Barrier) in [0,1].
    * @method progress
    * @return progress {Number}
    *
     */

    Barrier.prototype.progress = function() {
      return 1 - this.remainingThreads / this.data.length;
    };


    /**
    * This method is called when the Sequence has executed all of its functions. It will then start executing all callbacks that previously have been added via `done()` (in the order they were added). No callback receives any parameters.
    * @protected
    * @method _execDoneCallbacks
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype._execDoneCallbacks = function() {
      var cb, len1, m, ref;
      ref = this._doneCallbacks;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        cb = ref[m];
        cb();
      }
      return this;
    };


    /**
    * This method sets the start and end callback that are executed before the Barrier starts and after it's done (but before the done callbacks are being executed).
    * @protected
    * @method while
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype["while"] = function(startCallback, endCallback, context) {
      if (context != null) {
        this._startCallback = function() {
          return context.startCallback();
        };
        this._endCallback = function() {
          return context.endCallback();
        };
      } else {
        this._startCallback = startCallback;
        this._endCallback = endCallback;
      }
      return this;
    };

    return Barrier;

  })();

  JSUtils.Doneable = new JSUtils.Sequence();


  /**
   * This is an implementation of a dictionary/hash that does not convert its keys into Strings. Keys can therefore actually by anything! :)
   * @class Configurator
   * @constructor
  *
   */

  JSUtils.Hash = (function() {

    /**
     * Creates a new Hash from a given JavaScript object.
     * @static
     * @method fromObject
     * @param object {Object}
    *
     */
    var _putObject;

    Hash.fromObject = function(obj) {
      var hash, key, val;
      hash = new JSUtils.Hash();
      for (key in obj) {
        val = obj[key];
        hash.put(key, val);
      }
      return hash;
    };

    function Hash(obj, defaultVal, equality) {
      var key, val;
      if (defaultVal == null) {
        defaultVal = null;
      }
      if (equality == null) {
        equality = function(a, b) {
          return a === b;
        };
      }
      this.keys = [];
      this.values = [];
      this.defaultVal = defaultVal;
      this.equality = equality;
      if (obj != null) {
        for (key in obj) {
          val = obj[key];
          this.put(key, val);
        }
      }
    }

    Hash.prototype.toObject = function() {
      var idx, key, len1, m, ref, res;
      res = {};
      ref = this.keys;
      for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
        key = ref[idx];
        res[key] = this.values[idx];
      }
      return res;
    };

    Hash.prototype.clone = function() {
      var res;
      res = new JSUtils.Hash();
      res.keys = this.keys.slice(0);
      res.values = this.values.slice(0);
      return res;
    };

    Hash.prototype.invert = function() {
      var res;
      res = new JSUtils.Hash();
      res.keys = this.values.slice(0);
      res.values = this.keys.slice(0);
      return res;
    };


    /**
     * Adds a new key-value pair or overwrites an existing one.
     * @private
     * @method _putObject
     * @param object {Object}
     * @return {Hash} This instance.
     * @chainable
    *
     */

    _putObject = function(obj) {
      var key, val;
      for (key in obj) {
        val = obj[key];
        this.put(key, val);
      }
      return this;
    };


    /**
     * Return the index of the given key
     * @method _findKeyIdx
     * @param key {mixed}
     * @return {Hash} This instance.
     * @chainable
    *
     */

    Hash.prototype._findKeyIdx = function(key) {
      var el, idx, len1, m, ref;
      ref = this.keys;
      for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
        el = ref[idx];
        if ((typeof this.equality === "function" ? this.equality(el, key) : void 0) || el === key) {
          return idx;
        }
      }
      return -1;
    };


    /**
     * Adds a new key-value pair or overwrites an existing one.
     * @method put
     * @param key {mixed}
     * @param val {mixed}
     * @return {Hash} This instance.
     * @chainable
    *
     */

    Hash.prototype.put = function(key, val) {
      var idx;
      if (val == null) {
        return _putObject.call(this, key);
      }
      idx = this._findKeyIdx(key);
      if (idx < 0) {
        this.keys.push(key);
        this.values.push(val);
      } else {
        this.keys[idx] = key;
        this.values[idx] = val;
      }
      return this;
    };


    /**
     * Returns the value (or null) for the specified key.
     * @method get
     * @param key {mixed}
     * @return {mixed}
    *
     */

    Hash.prototype.get = function(key) {
      var idx;
      idx = this._findKeyIdx(key);
      if (idx >= 0) {
        return this.values[idx];
      }
      return (typeof this.defaultVal === "function" ? this.defaultVal(key) : void 0) || this.defaultVal;
    };


    /**
     * Returns a list of all key-value pairs. Each pair is an Array with the 1st element being the key, the 2nd being the value.
     * @method getAll
     * @return {Array} Key-value pairs.
    *
     */

    Hash.prototype.getAll = function() {
      var idx, key, len1, m, ref, res;
      res = [];
      ref = this.keys;
      for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
        key = ref[idx];
        res.push([key, this.values[idx]]);
      }
      return res;
    };


    /**
     * Indicates whether the Hash has the specified key.
     * @method hasKey
     * @param key {mixed}
     * @return {Boolean}
    *
     */

    Hash.prototype.has = function(key) {
      return this._findKeyIdx(key) >= 0;
    };

    Hash.prototype.hasKey = function() {
      return this.has.apply(this, arguments);
    };


    /**
     * Returns the number of entries in the Hash.
     * @method size
     * @return {Integer}
    *
     */

    Hash.prototype.size = function() {
      return this.keys.length;
    };


    /**
     * Returns all the keys of the Hash.
     * @method getKeys()
     * @return {Array}
    *
     */

    Hash.prototype.getKeys = function(clone) {
      if (clone == null) {
        clone = true;
      }
      if (clone === true) {
        return this.keys.slice(0);
      }
      return this.keys;
    };


    /**
     * Returns all the values of the Hash.
     * @method getValues()
     * @return {Array}
    *
     */

    Hash.prototype.getValues = function(clone) {
      if (clone == null) {
        clone = true;
      }
      if (clone === true) {
        return this.values.slice(0);
      }
      return this.values;
    };


    /**
     * Returns a list of keys that have val (or anything equal as specified in 'eqFunc') as value.
     * @method getKeysForValue
     * @param val {mixed}
     * @return {mixed}
    *
     */

    Hash.prototype.getKeysForValue = function(value) {
      var idx, idxs, val;
      idxs = (function() {
        var len1, m, ref, results;
        ref = this.values;
        results = [];
        for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
          val = ref[idx];
          if (this.equality(val, value) || val === value) {
            results.push(idx);
          }
        }
        return results;
      }).call(this);
      return (function() {
        var len1, m, results;
        results = [];
        for (m = 0, len1 = idxs.length; m < len1; m++) {
          idx = idxs[m];
          results.push(this.keys[idx]);
        }
        return results;
      }).call(this);
    };

    Hash.prototype.empty = function() {
      this.keys = [];
      this.values = [];
      return this;
    };

    Hash.prototype.remove = function(key) {
      var idx;
      idx = this._findKeyIdx(key);
      if (idx >= 0) {
        this.keys.splice(idx, 1);
        this.values.splice(idx, 1);
      } else {
        console.warn("Could not remove key '" + key + "'!");
      }
      return this;
    };

    Hash.prototype.each = function(callback, order) {
      var i, idx, key, keys, len1, len2, m, o, ref;
      if (!(order instanceof Function)) {
        ref = this.keys;
        for (i = m = 0, len1 = ref.length; m < len1; i = ++m) {
          key = ref[i];
          if (callback(key, this.values[i], i) === false) {
            return this;
          }
        }
      } else {
        keys = this.keys.slice(0);
        keys.sort(order);
        for (i = o = 0, len2 = keys.length; o < len2; i = ++o) {
          key = keys[i];
          idx = this._findKeyIdx(key);
          if (callback(key, this.values[idx], i) === false) {
            return this;
          }
        }
      }
      return this;
    };

    return Hash;

  })();

  arrEquals = function(arr1, arr2) {
    var i, len1, m, x;
    if (arr1.length !== arr2.length) {
      return false;
    }
    for (i = m = 0, len1 = arr1.length; m < len1; i = ++m) {
      x = arr1[i];
      if (x !== arr2[i]) {
        return false;
      }
    }
    return true;
  };

  funcForArgs = function(args, argLists, funcs) {
    var arg, argList, argListToCheck, i, lastMatchedIdx, len1, m;
    argListToCheck = (function() {
      var len1, m, results;
      results = [];
      for (m = 0, len1 = args.length; m < len1; m++) {
        arg = args[m];
        results.push(arg.constructor);
      }
      return results;
    })();
    for (i = m = 0, len1 = argLists.length; m < len1; i = ++m) {
      argList = argLists[i];
      if (arrEquals(argList, argListToCheck)) {
        return funcs[i] || funcs[lastMatchedIdx];
      }
      lastMatchedIdx = i;
    }
    return null;
  };

  JSUtils.overload = function() {
    var arg, argList, argLists, args, funcs, i, j, k, len, m, name, ref, type;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    argLists = [];
    funcs = [];
    i = 0;
    len = args.length;
    while (i < len) {
      j = i;
      while (!((argList = args[j]) instanceof Function) && j < len) {
        if (!(argList instanceof Array)) {
          argLists.push((function() {
            var results;
            results = [];
            for (name in argList) {
              type = argList[name];
              results.push(type);
            }
            return results;
          })());
        } else {
          argLists.push(argList);
        }
        j++;
      }
      if (j < len) {
        funcs.push(args[j]);
        for (k = m = 0, ref = j - i - 1; 0 <= ref ? m < ref : m > ref; k = 0 <= ref ? ++m : --m) {
          funcs.push(null);
        }
        i = j + 1;
      } else {
        throw new Error("No function given for argument lists: " + (JSON.stringify((function() {
          var len1, o, ref1, results;
          ref1 = args.slice(i);
          results = [];
          for (o = 0, len1 = ref1.length; o < len1; o++) {
            argList = ref1[o];
            results.push((function() {
              var len2, p, results1;
              results1 = [];
              for (p = 0, len2 = argList.length; p < len2; p++) {
                arg = argList[p];
                results1.push(arg.name);
              }
              return results1;
            })());
          }
          return results;
        })())));
      }
    }
    return function() {
      var f;
      if ((f = funcForArgs(arguments, argLists, funcs)) != null) {
        return f.apply(this, arguments);
      }
      throw new Error("Arguments do not match any known argument list!");
    };
  };

  prototyping = {};

  aliasing = {};

  preferJSUtils = true;

  prototyping["Math"] = {
    isNum: function(n) {
      return (n != null) && (typeof n === "number" || n instanceof Number) && isFinite(n);
    },
    average: function() {
      var elem, elems, len1, m, sum, vals;
      vals = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      sum = 0;
      elems = 0;
      for (m = 0, len1 = vals.length; m < len1; m++) {
        elem = vals[m];
        if (!(Math.isNum(elem))) {
          continue;
        }
        sum += elem;
        elems++;
      }
      return sum / elems;
    },
    sign: function(n) {
      if (Math.isNum(n)) {
        if (n < 0) {
          return -1;
        }
        if (n > 0) {
          return 1;
        }
        return 0;
      }
      return void 0;
    },
    log10: function(x) {
      if (Math.isNum(x) && x > 0) {
        return Math.log(x) / Math.LN10;
      }
      return void 0;
    }
  };

  prototyping["Function.prototype"] = {
    clone: function() {
        var that = this;
        var temp = function temporary() { return that.apply(this, arguments); };
        for( key in this ) {
            temp[key] = this[key];
        }
        return temp;
    }
  };

  prototyping["Object"] = {
    except: function() {
      var k, keys, obj, res, v;
      obj = arguments[0], keys = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (keys.first instanceof Array) {
        keys = keys.first;
      }
      keys = keys.concat(Object.keys(obj.__proto__));
      res = {};
      for (k in obj) {
        v = obj[k];
        if (indexOf.call(keys, k) < 0) {
          res[k] = v;
        }
      }
      res.__proto__ = obj.__proto__;
      return res;
    },
    values: function(obj) {
      var key, val;
      if (DEBUG) {
        if (!(obj instanceof Object)) {
          throw new Error("Called non-object: " + obj);
        }
      }
      return (function() {
        var results;
        results = [];
        for (key in obj) {
          val = obj[key];
          results.push(val);
        }
        return results;
      })();
    },
    swapValues: function() {
      var i, key1, key2, keys, m, obj, ref, temp;
      obj = arguments[0], keys = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (keys.length % 2 === 0) {
        for (i = m = 0, ref = keys.length; m < ref; i = m += 2) {
          key1 = keys[i];
          key2 = keys[i + 1];
          temp = obj[key1];
          obj[key1] = obj[key2];
          obj[key2] = temp;
        }
      }
      return obj;
    }
  };

  prototyping["Element.prototype"] = {
    remove: function() {
      return this.parentNode.removeChild(this);
    }
  };

  prototyping["String.prototype"] = {
    replaceMultiple: function(array, mode) {
      var cbFun, i, length, m, modes, needle, o, ref, ref1, repl, temp;
      if ((array == null) || array.length < 2) {
        return this;
      }
      length = array.length;
      modes = {
        0: 0,
        tuples: 0,
        1: 1,
        diffByOne: 1,
        2: 2,
        oneByDiff: 2
      };
      mode = modes[mode];
      if (mode == null) {
        mode = 0;
      }
      temp = this;
      if (mode === 0) {
        if (length & 1) {
          return this;
        }
        for (i = m = 0, ref = length; m < ref; i = m += 2) {
          temp = temp.replace(array[i], array[i + 1]);
        }
      }
      if (mode === 1) {
        repl = array[length - 1];
        for (i = o = 0, ref1 = length - 1; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
          temp = temp.replace(array[i], repl);
        }
      }
      if (mode === 2) {
        if (length !== 2) {
          return this;
        }
        needle = array.first;
        cbFun = array.second;
        i = 0;
        while (temp.indexOf(needle) !== -1 && i < temp.length) {
          temp = temp.replace(needle, cbFun(i));
          i++;
        }
      }
      return temp;
    },
    firstToUpper: function() {
      return this.charAt(0).toUpperCase() + this.slice(1);
    },
    firstToLower: function() {
      return this.charAt(0).toLowerCase() + this.slice(1);
    },
    capitalize: function() {
      var len1, m, ref, res, word;
      res = "";
      ref = this.split(" ");
      for (m = 0, len1 = ref.length; m < len1; m++) {
        word = ref[m];
        res += (word.firstToUpper()) + " ";
      }
      return res.trim();
    },
    camelToKebab: function() {
      return this.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/\b([A-Z]+)([A-Z])([a-z])/, '$1-$2$3').toLowerCase();
    },
    snakeToCamel: function() {
      var char, len1, m, prevChar, res;
      res = "";
      for (m = 0, len1 = this.length; m < len1; m++) {
        char = this[m];
        if (char !== "_") {
          if (prevChar !== "_") {
            res += char;
          } else {
            res += char.toUpperCase();
          }
        }
        prevChar = char;
      }
      return res;
    },
    camelToSnake: function() {
      var char, len1, m, prevChar, res;
      res = "";
      prevChar = null;
      for (m = 0, len1 = this.length; m < len1; m++) {
        char = this[m];
        if (char === char.toLowerCase()) {
          res += char;
        } else {
          if (prevChar) {
            res += "_" + char.toLowerCase();
          } else {
            res += char.toLowerCase();
          }
        }
        prevChar = char;
      }
      return res;
    },
    isNumeric: function() {
      var parsed;
      parsed = parseFloat(this);
      return (("" + parsed) === ("" + this) || ("+" + parsed) === ("" + this)) && Math.isNum(parsed);
    },
    endsWith: function(end) {
      var index;
      index = this.lastIndexOf(end);
      if (index >= 0) {
        return index + end.length === this.length;
      }
      return false;
    },
    times: function(n) {
      var i, m, ref, res;
      if (n == null) {
        n = 1;
      }
      res = "" + this;
      for (i = m = 1, ref = n; 1 <= ref ? m < ref : m > ref; i = 1 <= ref ? ++m : --m) {
        res += "" + this;
      }
      return res;
    },
    encodeHTMLEntities: function() {
      return this.replace(/[\u00A0-\u9999<>\&]/gim, function(i) {
        return "&#" + (i.charCodeAt(0)) + ";";
      });
    }
  };

  aliasing["String.prototype"] = {
    lower: "toLowerCase",
    upper: "toUpperCase"
  };

  prototyping["Array.prototype"] = {
    unique: function() {
      var elem, len1, m, res;
      res = [];
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        if (indexOf.call(res, elem) < 0) {
          res.push(elem);
        }
      }
      return res;
    },
    uniqueBy: function(propGetter, equals) {
      var done, duplicate, elem, len1, len2, m, o, res;
      if (propGetter == null) {
        propGetter = function(item) {
          return item;
        };
      }
      if (equals == null) {
        equals = function(a, b) {
          return a === b;
        };
      }
      res = [];
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        duplicate = false;
        for (o = 0, len2 = res.length; o < len2; o++) {
          done = res[o];
          if (!(equals(propGetter(done), propGetter(elem)))) {
            continue;
          }
          duplicate = true;
          break;
        }
        if (!duplicate) {
          res.push(elem);
        }
      }
      return res;
    },
    intersect: function(arr) {
      var elem;
      arr = arr;
      return ((function() {
        var len1, m, results;
        results = [];
        for (m = 0, len1 = this.length; m < len1; m++) {
          elem = this[m];
          if (indexOf.call(arr, elem) >= 0) {
            results.push(elem);
          }
        }
        return results;
      }).call(this)).unique();
    },
    intersects: function(arr) {
      return this.intersect(arr).length > 0;
    },
    groupBy: function(groupFun, equality) {
      var dict, elem, grouped, len1, m;
      dict = new JSUtils.Hash(null, equality);
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        grouped = groupFun(elem);
        if (dict.get(grouped) == null) {
          dict.put(grouped, []);
        }
        dict.get(grouped).push(elem);
      }
      return dict;
    },
    insert: function() {
      var elements, index;
      index = arguments[0], elements = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.splice.apply(this, [index, 0].concat(slice.call(elements)));
      return this;
    },
    remove: function() {
      var arg, elem, elements, equals, idx, indices, len1, len2, len3, m, myElem, o, p, q, removeAllOccurences, x;
      elements = 3 <= arguments.length ? slice.call(arguments, 0, m = arguments.length - 2) : (m = 0, []), equals = arguments[m++], removeAllOccurences = arguments[m++];
      if (removeAllOccurences == null) {
        removeAllOccurences = false;
      }
      if (arguments.length < 3) {
        elements = (function() {
          var len1, o, results;
          results = [];
          for (o = 0, len1 = arguments.length; o < len1; o++) {
            arg = arguments[o];
            results.push(arg);
          }
          return results;
        }).apply(this, arguments);
        equals = null;
        removeAllOccurences = null;
      }
      if (equals == null) {
        equals = function(a, b) {
          return a === b;
        };
      }
      for (o = 0, len1 = elements.length; o < len1; o++) {
        elem = elements[o];
        indices = [];
        for (idx = p = 0, len2 = this.length; p < len2; idx = ++p) {
          myElem = this[idx];
          if (!(equals(myElem, elem))) {
            continue;
          }
          indices.push(idx);
          if (!removeAllOccurences) {
            break;
          }
        }
        for (x = q = 0, len3 = indices.length; q < len3; x = ++q) {
          idx = indices[x];
          this.splice(idx - x, 1);
        }
      }
      return this;
    },
    removeAt: function(idx) {
      this.splice(idx, 1);
      return this;
    },
    moveElem: function(fromIdx, toIdx) {
      var e, elem, i, len1, m, res;
      res = [];
      elem = this[fromIdx];
      for (i = m = 0, len1 = this.length; m < len1; i = ++m) {
        e = this[i];
        if (!(i !== fromIdx)) {
          continue;
        }
        res.push(e);
        if (i === toIdx) {
          res.push(elem);
        }
      }
      return res;
    },
    flatten: function() {
      return Array.prototype.concat.apply([], this);
    },
    cloneDeep: function() {
      var elem, i, len1, m;
      for (i = m = 0, len1 = this.length; m < len1; i = ++m) {
        elem = this[i];
        if (elem instanceof Array) {
          this[i] = elem.cloneDeep();
        }
      }
      return this.clone();
    },
    except: function() {
      var el, elements;
      elements = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function() {
        var len1, m, results;
        results = [];
        for (m = 0, len1 = this.length; m < len1; m++) {
          el = this[m];
          if (indexOf.call(elements, el) < 0) {
            results.push(el);
          }
        }
        return results;
      }).call(this);
    },

    /**
    * Returns the first element that fulfills the condition in a recursive search.
    * @param condition {Function}
    * @param getSubArray {Function}
    * Optional. If given, it's used to retrieve the next (lower) array for recursion.
    * Default: Go deeper only on elements that are arrays themselves.
    *
     */
    find: function(condition, getSubArray) {
      var item, len1, m, res, subArray;
      if (!(condition instanceof Function)) {
        condition = function(item) {
          return item === condition;
        };
      }
      if (getSubArray == null) {
        getSubArray = function(item) {
          return item;
        };
      }
      for (m = 0, len1 = this.length; m < len1; m++) {
        item = this[m];
        if (condition(item) === true) {
          return item;
        }
        if ((subArray = getSubArray(item)) instanceof Array) {
          if ((res = subArray.find(condition, getSubArray)) != null) {
            return res;
          }
        }
      }
      return null;
    },
    binIndexOf: function(searchElement) {
      var currentElement, currentIndex, maxIndex, minIndex;
      minIndex = 0;
      maxIndex = this.length - 1;
      while (minIndex <= maxIndex) {
        currentIndex = Math.floor((minIndex + maxIndex) / 2);
        currentElement = this[currentIndex];
        if (currentElement < searchElement) {
          minIndex = currentIndex + 1;
        } else if (currentElement > searchElement) {
          maxIndex = currentIndex - 1;
        } else {
          return currentIndex;
        }
      }
      return -1;
    },
    sortByProp: function(propGetter, order) {
      var cmpFunc;
      if (order == null) {
        order = "asc";
      }
      if (propGetter == null) {
        propGetter = function(item) {
          return item;
        };
      }
      if (order === "asc") {
        cmpFunc = function(a, b) {
          a = propGetter(a);
          b = propGetter(b);
          if (a < b) {
            return -1;
          }
          if (b < a) {
            return 1;
          }
          return 0;
        };
      } else {
        cmpFunc = function(a, b) {
          a = propGetter(a);
          b = propGetter(b);
          if (a > b) {
            return -1;
          }
          if (b > a) {
            return 1;
          }
          return 0;
        };
      }
      return this.sort(cmpFunc);
    },

    /**
     * @method getMax
     * @param {Function} propertyGetter
     * The passed callback extracts the value being compared from the array elements.
     * @return {Array} An array of all maxima.
    *
     */
    getMax: function(propertyGetter) {
      var elem, len1, m, max, res, val;
      max = null;
      res = [];
      if (propertyGetter == null) {
        propertyGetter = function(item) {
          return item;
        };
      }
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        val = propertyGetter(elem);
        if (val > max || max === null) {
          max = val;
          res = [elem];
        } else if (val === max) {
          res.push(elem);
        }
      }
      return res;
    },
    getMin: function(propertyGetter) {
      var elem, len1, m, min, res, val;
      min = null;
      res = [];
      if (propertyGetter == null) {
        propertyGetter = function(item) {
          return item;
        };
      }
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        val = propertyGetter(elem);
        if (val < min || min === null) {
          min = val;
          res = [elem];
        } else if (val === min) {
          res.push(elem);
        }
      }
      return res;
    },
    reverseCopy: function() {
      var item;
      return (function() {
        var m, results;
        results = [];
        for (m = this.length - 1; m >= 0; m += -1) {
          item = this[m];
          results.push(item);
        }
        return results;
      }).call(this);
    },
    sample: function(n, forceArray) {
      var arr, elem, i, res;
      if (n == null) {
        n = 1;
      }
      if (forceArray == null) {
        forceArray = false;
      }
      if (n === 1) {
        if (!forceArray) {
          return this[Math.floor(Math.random() * this.length)];
        }
        return [this[Math.floor(Math.random() * this.length)]];
      }
      if (n > this.length) {
        n = this.length;
      }
      i = 0;
      res = [];
      arr = this.clone();
      while (i++ < n) {
        elem = arr.sample(1);
        res.push(elem);
        arr.remove(elem);
      }
      return res;
    },
    shuffle: function() {
      var arr, elem, i, len1, m;
      arr = this.sample(this.length);
      for (i = m = 0, len1 = arr.length; m < len1; i = ++m) {
        elem = arr[i];
        this[i] = elem;
      }
      return this;
    },
    swap: function(i, j) {
      var tmp;
      tmp = this[i];
      this[i] = this[j];
      this[j] = tmp;
      return this;
    },
    times: function(n) {
      var i, m, ref, res;
      res = this.clone();
      for (i = m = 1, ref = n; 1 <= ref ? m < ref : m > ref; i = 1 <= ref ? ++m : --m) {
        res = res.merge(this);
      }
      return res;
    },
    and: function(elem) {
      return this.concat([elem]);
    },
    merge: function(array) {
      Array.prototype.push.apply(this, array);
      return this;
    },
    noNulls: function() {
      var e, len1, m, res;
      res = [];
      for (m = 0, len1 = this.length; m < len1; m++) {
        e = this[m];
        if (e != null) {
          res.push(e);
        }
      }
      return res;
    },
    getLast: function(n) {
      if (n == null) {
        n = 1;
      }
      return this.slice(-n);
    },
    average: {
      get: function() {
        return Math.average.apply(null, this);
      },
      set: function() {}
    },
    last: {
      get: function() {
        return this[this.length - 1];
      },
      set: function(val) {
        this[this.length - 1] = val;
        return this;
      }
    },
    sum: {
      get: function() {
        var elem, len1, m, res;
        res = 0;
        for (m = 0, len1 = this.length; m < len1; m++) {
          elem = this[m];
          if (Math.isNum(elem)) {
            res += elem;
          }
        }
        return res;
      },
      set: function() {
        console.warn("[].sum is not settable!");
        return this;
      }
    },
    first: {
      get: function() {
        return this[0];
      },
      set: function(val) {
        this[0] = val;
        return this;
      }
    },
    second: {
      get: function() {
        return this[1];
      },
      set: function(val) {
        this[1] = val;
        return this;
      }
    },
    third: {
      get: function() {
        return this[2];
      },
      set: function(val) {
        this[2] = val;
        return this;
      }
    },
    fourth: {
      get: function() {
        return this[3];
      },
      set: function(val) {
        this[3] = val;
        return this;
      }
    },
    fifth: {
      get: function() {
        return this[4];
      },
      set: function(val) {
        this[4] = val;
        return this;
      }
    },
    sixth: {
      get: function() {
        return this[5];
      },
      set: function(val) {
        this[5] = val;
        return this;
      }
    },
    seventh: {
      get: function() {
        return this[6];
      },
      set: function(val) {
        this[6] = val;
        return this;
      }
    },
    eighth: {
      get: function() {
        return this[7];
      },
      set: function(val) {
        this[7] = val;
        return this;
      }
    },
    ninth: {
      get: function() {
        return this[8];
      },
      set: function(val) {
        this[8] = val;
        return this;
      }
    },
    tenth: {
      get: function() {
        return this[9];
      },
      set: function(val) {
        this[9] = val;
        return this;
      }
    },
    eleventh: {
      get: function() {
        return this[10];
      },
      set: function(val) {
        this[10] = val;
        return this;
      }
    },
    twelveth: {
      get: function() {
        return this[11];
      },
      set: function(val) {
        this[11] = val;
        return this;
      }
    }
  };

  aliasing["Array.prototype"] = {
    prepend: "unshift",
    append: "push",
    clone: "slice",
    without: "except"
  };

  prototyping["$.fn"] = {
    content: function(content) {
      var children, text;
      if (content != null) {
        if (typeof content === "string") {
          children = this.children().detach();
          this.empty().append(content).append(children);
        }
        return this;
      } else {
        children = this.children().detach();
        text = this.text();
        this.append(children);
        return text.trim();
      }
    },
    toggleAttr: function(attr, val1, val2) {
      var $elem, elem, len1, m;
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        $elem = $(elem);
        if ((val1 != null) && (val2 != null)) {
          $elem.attr("data-toggle-attr-" + attr + "-val1", val1);
          $elem.attr("data-toggle-attr-" + attr + "-val2", val2);
        } else {
          val1 = $elem.attr("data-toggle-attr-" + attr + "-val1");
          val2 = $elem.attr("data-toggle-attr-" + attr + "-val2");
        }
        if ($elem.attr(attr) === val1) {
          $elem.attr(attr, val2);
        } else {
          $elem.attr(attr, val1);
        }
      }
      return this;
    },
    toggleCss: function(attr, val1, val2) {
      var $elem, elem, len1, m;
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        $elem = $(elem);
        if ((val1 != null) && (val2 != null)) {
          $elem.attr("data-toggle-css-" + attr + "-val1", val1);
          $elem.attr("data-toggle-css-" + attr + "-val2", val2);
        } else {
          val1 = $elem.attr("data-toggle-css-" + attr + "-val1");
          val2 = $elem.attr("data-toggle-css-" + attr + "-val2");
        }
        if ($elem.css(attr) === val1) {
          $elem.css(attr, val2);
        } else {
          $elem.css(attr, val1);
        }
      }
      return this;
    },
    dimensions: function() {
      var res;
      res = {
        x: this.width(),
        y: this.height()
      };
      res.width = res.x;
      res.height = res.y;
      return res;
    },
    outerDimensions: function(margins) {
      var res;
      if (margins == null) {
        margins = true;
      }
      res = {
        x: this.outerWidth(margins),
        y: this.outerHeight(margins)
      };
      res.width = res.x;
      res.height = res.y;
      return res;
    },
    showNow: function(display) {
      if (display == null) {
        display = "block";
      }
      this[0].style.display = display;
      return this;
    },
    hideNow: function() {
      this[0].style.display = "none";
      return this;
    },
    inDom: function() {
      return $.contains(document.documentElement, this[0]);
    },
    wrapAll: function(wrapper) {
      if (!(wrapper instanceof $)) {
        wrapper = $(wrapper);
      }
      wrapper.append(this);
      return this;
    }
  };

  prototyping["$.Color.fn"] = {
    distanceTo: function(color, distFunc) {
      if (distFunc == null) {
        distFunc = function(c1, c2) {
          return Math.abs(c1.red() - c2.red()) + Math.abs(c1.green() - c2.green()) + Math.abs(c1.blue() - c2.blue());
        };
      }
      return distFunc(this, color);
    },
    isSimilarTo: function(color) {
      return this.distanceTo(color) / 255 < (1 - 1 / 1.61803398875);
    },
    toRgbaString: function() {
      return "rgba(" + (this._rgba.join(",")) + ")";
    }
  };

  getObjectFromPath = function(path) {
    var len1, m, part, parts, res;
    parts = path.split(".");
    res = window;
    for (m = 0, len1 = parts.length; m < len1; m++) {
      part = parts[m];
      res = res != null ? res[part] : void 0;
    }
    return res;
  };

  for (setName in prototyping) {
    set = prototyping[setName];
    parent = getObjectFromPath(setName);
    if (parent == null) {
      continue;
    }
    if (!preferJSUtils) {
      for (methodName in set) {
        method = set[methodName];
        if (parent[methodName] != null) {
          methodName = "_" + methodName;
        }
        if (method instanceof Function) {
          Object.defineProperty(parent, methodName, {
            value: method,
            configurable: false,
            enumerable: false,
            writable: false
          });
        } else {
          Object.defineProperty(parent, methodName, method);
        }
      }
      if (aliasing[setName] != null) {
        ref = aliasing[setName];
        for (aliasName in ref) {
          methodName = ref[aliasName];
          if (parent[aliasName] != null) {
            aliasName = "_" + aliasName;
          }
          parent[aliasName] = parent[methodName];
        }
      }
    } else {
      for (methodName in set) {
        method = set[methodName];
        if (parent[methodName] != null) {
          parent["_" + methodName] = parent[methodName];
        }
        if (method instanceof Function) {
          Object.defineProperty(parent, methodName, {
            value: method,
            configurable: false,
            enumerable: false,
            writable: false
          });
        } else {
          Object.defineProperty(parent, methodName, method);
        }
      }
      if (aliasing[setName] != null) {
        ref1 = aliasing[setName];
        for (aliasName in ref1) {
          methodName = ref1[aliasName];
          if (parent[aliasName] != null) {
            parent["_" + aliasName] = parent[aliasName];
          }
          parent[aliasName] = parent[methodName];
        }
      }
    }
  }

  isTree = function(obj) {
    return obj instanceof JSUtils.Tree || (obj != null ? typeof obj.__instanceof__ === "function" ? obj.__instanceof__(JSUtils.Tree) : void 0 : void 0) || false;
  };

  JSUtils.Tree = (function() {
    Tree._newOptions = function(CLASS) {
      return {
        getChildren: function(nodeData) {
          return nodeData.children;
        },
        instantiate: function(nodeData) {
          return new CLASS(nodeData);
        },
        afterInstantiate: function(nodeData, node) {
          return false;
        },
        adjustLevels: true
      };
    };


    /**
    * @method new
    * @static
    * @param node {Object}
    * @param options {Object}
    * Optional. Any given key will override the default. Here are the keys:
    * adjustLevels: Boolean value that indicates whether the tree is supposed to do its aftermath. Only set this to false if you're doing the aftermath later!!
    * afterInstantiate: Function to modify the node and/or the instance. Parameters are (1st) the node object and (2nd) the instance.
    * getChildren: Function that specifies how to retrieve the children from the node object.
    * getParent: Function that specifies how to retrieve the parent from the node object. getChildren is checked 1st so it doesn't make sense to pass getChildren AND getParent!
    * instantiate: Function that specifies how to create an instance from the node object. Parameter is the node object.
    *
     */

    Tree._new = function(node, options) {
      var CLASS;
      CLASS = this;
      if ((node == null) || isTree(node)) {
        return new CLASS(node);
      }
      if ((node.children != null) || options.getChildren instanceof Function) {
        return CLASS["new"].byChildRef(node, options);
      }
      if ((node.parent != null) || options.getParent instanceof Function) {
        return CLASS["new"].byParentRef(node, options);
      }
      return new CLASS(node, options);
    };


    /**
    * @method new.byChildRef
    * @static
    * @param node {Object}
    * @param options {Object}
    * Optional. Any given key will override the default. Here are the keys:
    * adjustLevels: Boolean value that indicates whether the tree is supposed to do its aftermath. Only set this to false if you're doing the aftermath later!!
    * afterInstantiate: Function to modify the node and/or the instance. Parameters are (1st) the node object and (2nd) the instance.
    * getChildren: Function that specifies how to retrieve the children from the node object.
    * instantiate: Function that specifies how to create an instance from the node object. Parameter is the node object.
    *
     */

    Tree._newByChildRef = function(node, options) {
      var CLASS, adjustLevels, child, childInstance, defaultOptions, len1, m, ref2, tree;
      CLASS = this;
      defaultOptions = CLASS._newOptions(CLASS);
      options = $.extend(defaultOptions, options);
      adjustLevels = options.adjustLevels;
      options.adjustLevels = false;
      tree = options.instantiate(node);
      options.afterInstantiate(node, tree);
      ref2 = options.getChildren(node) || [];
      for (m = 0, len1 = ref2.length; m < len1; m++) {
        child = ref2[m];
        childInstance = CLASS["new"].byChildRef(child, options);
        tree.addChild(childInstance, null, false);
      }
      if (adjustLevels) {
        tree._adjustLevels(0);
      }
      return tree;
    };


    /**
    * @method new.byParentRef
    * @static
    * @param node {Object}
    * @param options {Object}
    * Optional. Any given key will override the default. Here are the keys:
    * adjustLevels: Boolean value that indicates whether the tree is supposed to do its aftermath. Only set this to false if you're doing the aftermath later!!
    * afterInstantiate: Function to modify the node and/or the instance. Parameters are (1st) the node object and (2nd) the instance.
    * getParent: Function that specifies how to retrieve the parent from the node object.
    * instantiate: Function that specifies how to create an instance from the node object. Parameter is the node object.
    *
     */

    Tree._newByParentRef = function(node, getParent) {
      var tree;
      return tree = new CLASS();
    };

    Tree.init = function() {
      var CLASS;
      CLASS = this;
      this["new"] = function() {
        return CLASS._new.apply(CLASS, arguments);
      };
      this["new"].byChildRef = function() {
        return CLASS._newByChildRef.apply(CLASS, arguments);
      };
      this["new"].byParentRef = function() {
        return CLASS._newByParentRef.apply(CLASS, arguments);
      };
      return this.fromRecursive = this["new"];
    };

    Tree.init();

    function Tree(node) {
      var forbiddenKeys, k, self, v;
      self = this;
      this.children = [];
      this.parent = null;
      this.descendants = [];
      this.orderMode = "postorder";
      if (node == null) {
        this.data = {};
      } else {
        this.data = node.data || node;
        forbiddenKeys = Object.keys(this.constructor.prototype).concat(["children", "parent", "descendants", "data", "orderMode", "getClass", "getClassName", "constructor"]);
        for (k in node) {
          v = node[k];
          if (indexOf.call(forbiddenKeys, k) < 0) {
            if (!(v instanceof Function)) {
              (function(k, v) {
                return Object.defineProperty(self, k, {
                  get: function() {
                    return self.data[k];
                  },
                  set: function(val) {
                    self.data[k] = val;
                    return self;
                  }
                });
              })(k, v);
            } else {
              (function(k, v) {
                return self[k] = function() {
                  return v.call.apply(v, [node].concat(slice.call(arguments)));
                };
              })(k, v);
            }
          }
        }
      }
    }

    Object.defineProperties(Tree.prototype, {
      depth: {
        get: function() {
          return this.getDepth();
        },
        set: function() {
          return this;
        }
      },
      size: {
        get: function() {
          return this.getSize();
        },
        set: function() {
          return this;
        }
      },
      level: {
        get: function() {
          return this.getLevel();
        },
        set: function() {
          return this;
        }
      },
      root: {
        get: function() {
          return this.getRoot();
        },
        set: function() {
          return this;
        }
      }
    });

    Tree.prototype._cacheDescendants = function() {
      var child, len1, m, ref2, res;
      res = [];
      ref2 = this.children;
      for (m = 0, len1 = ref2.length; m < len1; m++) {
        child = ref2[m];
        if (!(child != null)) {
          continue;
        }
        child._cacheDescendants();
        res = res.concat(child.descendants);
      }
      this.descendants = this.children.concat(res);
      return this;
    };

    Tree.prototype._adjustLevels = function(startLevel) {
      if (startLevel == null) {
        startLevel = 0;
      }
      this._cacheDescendants().each(function(n, l, i) {
        n._level = startLevel + l;
        return true;
      });
      return this;
    };

    Tree.prototype.hasNode = function(node) {
      return this === node || indexOf.call(this.descendants, node) >= 0;
    };


    /**
    * Find (first occurence of) a node
    * @method findNode
    * @param equalsFunction {Function}
    *
     */

    Tree.prototype.findNode = function(filter) {
      var ref2;
      return ((ref2 = this.findNodes(filter)) != null ? ref2.first : void 0) || null;
    };

    Tree.prototype.findDescendant = function() {
      return this.findNode.apply(this, arguments);
    };


    /**
    * Find all occurences of a node.
    * @method findNodes
    * @param equalsFunction {Function}
    *
     */

    Tree.prototype.findNodes = function(filter) {
      var node;
      if (filter instanceof Function) {
        return (function() {
          var len1, m, ref2, results;
          ref2 = this.descendants;
          results = [];
          for (m = 0, len1 = ref2.length; m < len1; m++) {
            node = ref2[m];
            if ((node != null) && filter(node)) {
              results.push(node);
            }
          }
          return results;
        }).call(this);
      }
      return [];
    };

    Tree.prototype.findDescendants = function() {
      return this.findNodes.apply(this, arguments);
    };

    Tree.prototype.getDepth = function() {
      var descendant, len1, m, maxLevel, ref2;
      if (this.children.length > 0) {
        maxLevel = null;
        ref2 = this.descendants;
        for (m = 0, len1 = ref2.length; m < len1; m++) {
          descendant = ref2[m];
          if ((descendant != null) && ((maxLevel == null) || descendant.level > maxLevel)) {
            maxLevel = descendant.level;
          }
        }
        return maxLevel - this.level;
      }
      return 0;
    };


    /**
    * Get number of nodes in (sub)tree
    *
     */

    Tree.prototype.getSize = function() {
      var descendant;
      return ((function() {
        var len1, m, ref2, results;
        ref2 = this.descendants;
        results = [];
        for (m = 0, len1 = ref2.length; m < len1; m++) {
          descendant = ref2[m];
          if (descendant != null) {
            results.push(descendant);
          }
        }
        return results;
      }).call(this)).length + 1;
    };

    Tree.prototype.getLevel = function() {
      return this._level;
    };

    Tree.prototype.getRoot = function() {
      var root;
      if ((root = this.parent) == null) {
        return this;
      }
      while (root.parent != null) {
        root = root.parent;
      }
      return root;
    };

    Tree.prototype.getLeaves = function() {
      var child, leaves, len1, m, ref2;
      leaves = [];
      ref2 = this.children;
      for (m = 0, len1 = ref2.length; m < len1; m++) {
        child = ref2[m];
        if (child != null) {
          if (child.children.length > 0) {
            leaves = leaves.concat(child.getLeaves());
          } else {
            leaves.push(child);
          }
        }
      }
      return leaves;
    };

    Tree.prototype.isLeaf = function() {
      return this.children.length === 0;
    };


    /**
    * Serialize the tree to a plain object.
    *
     */

    Tree.prototype.serialize = function(toString, format, doneNodes) {
      var base, base1, child, len1, m, ref2, res, serializedChildren;
      if (toString == null) {
        toString = false;
      }
      if (doneNodes == null) {
        doneNodes = [];
      }
      serializedChildren = [];
      ref2 = this.children;
      for (m = 0, len1 = ref2.length; m < len1; m++) {
        child = ref2[m];
        if (!(indexOf.call(doneNodes, child) < 0)) {
          continue;
        }
        doneNodes.push(child);
        serializedChildren.push((child != null ? typeof child.serialize === "function" ? child.serialize(false, format, doneNodes) : void 0 : void 0) || {});
      }
      if (format == null) {
        res = (typeof (base = this.data).serialize === "function" ? base.serialize() : void 0) || JSON.parse(JSON.stringify(this.data));
        if (serializedChildren.length > 0) {
          res.children = serializedChildren;
        }
        if (!toString) {
          return res;
        }
        return JSON.stringify(res);
      }
      res = format(this, serializedChildren, (typeof (base1 = this.data).serialize === "function" ? base1.serialize() : void 0) || JSON.parse(JSON.stringify(this.data)));
      if (!toString) {
        return res;
      }
      return JSON.stringify(res);
    };

    Tree.prototype.deserialize = function(data) {
      var key, tree, val;
      tree = this.constructor["new"](data);
      this.setChildren(tree.children);
      for (key in data) {
        val = data[key];
        if (key !== "children") {
          this[key] = val;
        }
      }
      return this;
    };

    Tree.prototype.toObject = function() {
      return this.serialize.apply(this, arguments);
    };

    Tree.prototype.getSiblings = function() {
      var node;
      if ((this.parent != null) && this.parent.children.length > 0) {
        return (function() {
          var len1, m, ref2, results;
          ref2 = this.parent.children;
          results = [];
          for (m = 0, len1 = ref2.length; m < len1; m++) {
            node = ref2[m];
            if (node !== this) {
              results.push(node);
            }
          }
          return results;
        }).call(this);
      }
      return [];
    };

    Tree.prototype.getLevelSiblings = function() {
      var self, siblings;
      self = this;
      siblings = this.getRoot().findNodes(function(node) {
        return node.level === self.level && node !== self;
      });
      return siblings || [];
    };

    Tree.prototype.getParent = function() {
      return this.parent;
    };

    Tree.prototype.getChildren = function() {
      return this.children;
    };

    Tree.prototype.getDescendants = function() {
      return this.descendants;
    };

    Tree.prototype.pathToRoot = function() {
      var res;
      res = [this];
      parent = this.parent;
      while (parent != null) {
        res.push(parent);
        parent = parent.parent;
      }
      return res;
    };

    Tree.prototype.pathFromRoot = function() {
      var res;
      res = this.pathToRoot();
      res.reverse();
      return res;
    };

    Tree.prototype.addChild = function(node, index, adjustLevels) {
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      if (!isTree(node)) {
        node = new this.constructor(node);
      }
      if ((node.parent != null) && node.parent !== this) {
        node.moveTo(this, index);
        return this;
      }
      if (index == null) {
        this.children.push(node);
      } else {
        this.children.splice(index, 0, node);
      }
      node.parent = this;
      if (adjustLevels) {
        this.getRoot()._adjustLevels();
      }
      return this;
    };

    Tree.prototype.appendChild = function() {
      return this.addChild.apply(this, arguments);
    };

    Tree.prototype.addChildren = function(nodes, index, adjustLevels) {
      var m, node;
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      for (m = nodes.length - 1; m >= 0; m += -1) {
        node = nodes[m];
        if (node != null) {
          this.addChild(node, index, false);
        }
      }
      if (adjustLevels) {
        this._adjustLevels(this.level);
      }
      return this;
    };

    Tree.prototype.appendChildren = function() {
      return this.addChildren.apply(this, arguments);
    };

    Tree.prototype.setChildren = function(nodes, clone, adjustLevels) {
      var len1, m, node;
      if (clone == null) {
        clone = false;
      }
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      this.children = [];
      if (clone) {
        nodes = (function() {
          var len1, m, results;
          results = [];
          for (m = 0, len1 = nodes.length; m < len1; m++) {
            node = nodes[m];
            results.push(node != null ? node.clone() : void 0);
          }
          return results;
        })();
      }
      for (m = 0, len1 = nodes.length; m < len1; m++) {
        node = nodes[m];
        this.addChild(node);
      }
      if (adjustLevels) {
        this._adjustLevels(this.level);
      }
      return this;
    };

    Tree.prototype.moveTo = function(targetParent, index, adjustLevels) {
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      this.remove(false);
      targetParent.addChild(this, index, adjustLevels);
      return this;
    };

    Tree.prototype.appendTo = function() {
      return this.moveTo.apply(this, arguments);
    };

    Tree.prototype.remove = function(adjustLevels) {
      var child;
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      if (this.parent != null) {
        this.parent.children = (function() {
          var len1, m, ref2, results;
          ref2 = this.parent.children;
          results = [];
          for (m = 0, len1 = ref2.length; m < len1; m++) {
            child = ref2[m];
            if (child !== this) {
              results.push(child);
            }
          }
          return results;
        }).call(this);
        this.parent._cacheDescendants();
        this.parent = null;
        if (adjustLevels) {
          this._adjustLevels();
        }
      }
      return this;
    };

    Tree.prototype.removeChild = function(param) {
      var node;
      if (typeof param === "number" || param instanceof Number) {
        node = this.children[param];
      } else if (param instanceof Function) {
        node = ((function() {
          var len1, m, ref2, results;
          ref2 = this.children;
          results = [];
          for (m = 0, len1 = ref2.length; m < len1; m++) {
            node = ref2[m];
            if (param(node)) {
              results.push(node);
            }
          }
          return results;
        }).call(this))[0];
      } else {
        node = param;
      }
      if ((node != null) && indexOf.call(this.children, node) >= 0) {
        node.remove();
      }
      return this;
    };


    /**
    * @method _traverse
    * @param callback {Function}
    * Gets the current node, the current level relative to the root of the current traversal, and iteration index as parameters.
    * @param orderMode {String}
    * Optional. Default is "postorder". Possible are "postorder", "preorder", "inorder", "levelorder".
    * @param searchMode {String}
    * Optional. Default is "depthFirst". Posible are "depthFirst", "breadthFirst".
    *
     */

    Tree.prototype._traverse = function(callback, orderMode, info) {
      if (orderMode == null) {
        orderMode = this.orderMode || "postorder";
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this
        };
      }
      return this[orderMode](callback, null, info);
    };

    Tree.prototype.each = function() {
      return this._traverse.apply(this, arguments);
    };

    Tree.prototype.postorder = function(callback, level, info) {
      var child, len1, m, ref2;
      if (level == null) {
        level = 0;
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this
        };
      }
      ref2 = this.children;
      for (m = 0, len1 = ref2.length; m < len1; m++) {
        child = ref2[m];
        if (!(child != null)) {
          continue;
        }
        child.postorder(callback, level + 1, info);
        info.idx++;
      }
      if (callback.call(info.ctx, this, level, info.idx) === false) {
        return this;
      }
      return this;
    };

    Tree.prototype.preorder = function(callback, level, info) {
      var child, len1, m, ref2;
      if (level == null) {
        level = 0;
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this
        };
      }
      if (callback.call(info.ctx, this, level, info.idx) === false) {
        return this;
      }
      ref2 = this.children;
      for (m = 0, len1 = ref2.length; m < len1; m++) {
        child = ref2[m];
        if (!(child != null)) {
          continue;
        }
        child.preorder(callback, level + 1, info);
        info.idx++;
      }
      return this;
    };

    Tree.prototype.inorder = function(callback, level, index, info) {
      var i, m, o, ref2, ref3, ref4, ref5, ref6;
      if (level == null) {
        level = 0;
      }
      if (index == null) {
        index = Math.floor(this.children.length / 2);
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this
        };
      }
      for (i = m = 0, ref2 = index; 0 <= ref2 ? m < ref2 : m > ref2; i = 0 <= ref2 ? ++m : --m) {
        if ((ref3 = this.children[i]) != null) {
          ref3.inorder(callback, level + 1, index, info);
        }
        info.idx++;
      }
      if (callback.call(info.ctx, this, level, info.idx) === false) {
        return this;
      }
      for (i = o = ref4 = index, ref5 = this.children.length; ref4 <= ref5 ? o < ref5 : o > ref5; i = ref4 <= ref5 ? ++o : --o) {
        if ((ref6 = this.children[i]) != null) {
          ref6.inorder(callback, level + 1, index, info);
        }
        info.idx++;
      }
      return this;
    };

    Tree.prototype.levelorder = function(callback, level, info) {
      var currentLevel, el, list, prevLevel, startLevel;
      if (level == null) {
        level = 0;
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this,
          levelIdx: 0
        };
      }
      list = [this];
      startLevel = this.level;
      prevLevel = 0;
      while (list.length > 0) {
        el = list.shift();
        if (el != null) {
          currentLevel = el.level - startLevel;
          if (currentLevel > prevLevel) {
            info.levelIdx = 0;
          }
          if (callback.call(info.ctx, el, currentLevel, info) === false) {
            return this;
          }
          prevLevel = currentLevel;
          info.idx++;
          info.levelIdx++;
          list = list.concat(el.children);
        }
      }
      return this;
    };

    return Tree;

  })();

  JSUtils.BinaryTree = (function(superClass) {
    extend(BinaryTree, superClass);

    BinaryTree._newOptions = function(CLASS) {
      var options;
      options = BinaryTree.__super__.constructor._newOptions.call(this, CLASS);
      options.instantiate = function(nodeData, compareNodes) {
        return new CLASS(nodeData, compareNodes);
      };
      return options;
    };

    BinaryTree._newByChildRef = function(node, options) {
      var CLASS, adjustLevels, child, childInstance, defaultOptions, len1, m, ref2, tree;
      CLASS = this;
      defaultOptions = CLASS._newOptions(CLASS);
      options = $.extend(defaultOptions, options);
      adjustLevels = options.adjustLevels;
      options.adjustLevels = false;
      tree = options.instantiate(node, options.compareNodes);
      options.afterInstantiate(node, tree);
      ref2 = options.getChildren(node) || [];
      for (m = 0, len1 = ref2.length; m < len1; m++) {
        child = ref2[m];
        childInstance = CLASS["new"].byChildRef(child, options);
        tree.addChild(childInstance, false);
      }
      if (adjustLevels) {
        tree._adjustLevels(0);
      }
      return tree;
    };

    BinaryTree.init();

    function BinaryTree(node, compareNodes) {
      if (compareNodes != null ? compareNodes.compareNodes : void 0) {
        compareNodes = compareNodes.compareNodes;
      }
      if (!(compareNodes instanceof Function) || compareNodes.length !== 2) {
        throw new Error("BinaryTree::constructor: Invalid nodes compare function given!");
      }
      BinaryTree.__super__.constructor.call(this, node);
      this.compareNodes = compareNodes;
      Object.defineProperties(this, {
        left: {
          get: function() {
            return this.children[0] || null;
          },
          set: function(node) {
            this.children[0] = node;
            return this;
          }
        },
        right: {
          get: function() {
            return this.children[1] || null;
          },
          set: function(node) {
            this.children[1] = node;
            return this;
          }
        }
      });
    }

    BinaryTree.prototype.balance = function() {
      var CLASS, index, insertNodes, n, nodes, resetNodeRelations, root;
      CLASS = this.constructor;
      nodes = [];
      this.inorder(function(node) {
        nodes.push(node);
        return true;
      });
      resetNodeRelations = function(node) {
        node.children = [];
        node.descendants = [];
        node.parent = null;
        return node;
      };
      index = Math.floor(nodes.length / 2);
      root = nodes[index];
      resetNodeRelations(root);
      nodes = (function() {
        var len1, m, results;
        results = [];
        for (m = 0, len1 = nodes.length; m < len1; m++) {
          n = nodes[m];
          if (n !== root) {
            results.push(n);
          }
        }
        return results;
      })();
      insertNodes = (function(_this) {
        return function(list) {
          var idx, len, node;
          len = list.length;
          if (len === 0) {
            return true;
          }
          idx = Math.floor(len / 2);
          if (idx === 2) {
            idx++;
          }
          node = list[idx];
          if (node !== _this) {
            node = resetNodeRelations(node);
          } else {
            node = new CLASS(node.data, _this.compareNodes);
          }
          root.addChild(node, false);
          insertNodes(list.slice(0, idx));
          insertNodes(list.slice(idx + 1));
          return true;
        };
      })(this);
      insertNodes(nodes.slice(0, index));
      insertNodes(nodes.slice(index + 1));
      this.data = root.data;
      this.children = root.children;
      this._adjustLevels();
      return this;
    };

    BinaryTree.prototype.addChild = function(node, adjustLevels) {
      var relation;
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      if (!isTree(node)) {
        node = new this.constructor(node, this.compareNodes);
      }
      relation = this.compareNodes(this, node);
      if (relation === 0) {
        return this;
      }
      if (relation < 0) {
        if (this.left != null) {
          this.left.addChild(node, adjustLevels);
          return this;
        } else {
          this.left = node;
          node.parent = this;
        }
      } else {
        if (this.right != null) {
          this.right.addChild(node, adjustLevels);
          return this;
        } else {
          this.right = node;
          node.parent = this;
        }
      }
      if (adjustLevels) {
        this.getRoot()._adjustLevels();
      }
      return this;
    };

    BinaryTree.prototype.addChildren = function(nodes, adjustLevels) {
      return BinaryTree.__super__.addChildren.call(this, nodes, null, adjustLevels);
    };

    BinaryTree.prototype.setChildren = function() {
      throw new Error("BinaryTree::setChildren: Children cannot be set. Use removeChild() and addChild()!");
    };

    BinaryTree.prototype.moveTo = function() {
      throw new Error("BinaryTree::moveTo: Cannot move a node!");
    };

    BinaryTree.prototype.appendTo = function() {
      throw new Error("BinaryTree::appendTo: Cannot move a node!");
    };

    BinaryTree.prototype.remove = function(adjustLevels) {
      var children;
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      if (this.parent != null) {
        children = this.parent.children;
        if (children[0] === this) {
          this.parent.children = [null, children[1]];
        } else {
          this.parent.children = [children[0], null];
        }
        this.parent._cacheDescendants();
        this.parent = null;
        if (adjustLevels) {
          this._adjustLevels();
        }
      }
      return this;
    };

    BinaryTree.prototype.deserialize = function(data) {
      var key, tree, val;
      tree = this.constructor["new"](data, {
        compareNodes: this.compareNodes
      });
      this.children = tree.children;
      for (key in data) {
        val = data[key];
        if (key !== "children") {
          this[key] = val;
        }
      }
      return this;
    };

    BinaryTree.prototype.inorder = function(callback, level, index, info) {
      var ref2, ref3;
      if (level == null) {
        level = 0;
      }
      if (index == null) {
        index = Math.floor(this.children.length / 2);
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this
        };
      }
      if ((ref2 = this.left) != null) {
        ref2.inorder(callback, level + 1, index, info);
      }
      info.idx++;
      if (callback.call(info.ctx, this, level, info.idx) === false) {
        return this;
      }
      if ((ref3 = this.right) != null) {
        ref3.inorder(callback, level + 1, index, info);
      }
      info.idx++;
      return this;
    };

    return BinaryTree;

  })(JSUtils.Tree);

  JSUtils.Leaf = (function(superClass) {
    var CLASS;

    extend(Leaf, superClass);

    CLASS = Leaf;

    Leaf["new"] = function(node) {
      return new this(node);
    };

    function Leaf(node) {
      Leaf.__super__.constructor.call(this, node);
      delete this.children;
      Object.defineProperty(this, "children", {
        get: function() {
          return [];
        },
        set: function() {
          throw new Error("JSUtils.Leaf::children=: Cannot set children of a leaf!");
        }
      });
    }

    Leaf.prototype._cacheDescendants = function() {
      return this;
    };

    Leaf.prototype.findNodes = function(param) {
      return null;
    };

    Leaf.prototype.getDepth = function() {
      return 0;
    };

    Leaf.prototype.getSize = function() {
      return 0;
    };

    Leaf.prototype.getLevel = function() {
      return this._level;
    };

    Leaf.prototype.getLeaves = function() {
      return [];
    };

    Leaf.prototype.isLeaf = function() {
      return true;
    };

    Leaf.prototype.serialize = function(format) {
      var base, base1;
      if (format == null) {
        return {
          children: [],
          data: (typeof (base = this.data).serialize === "function" ? base.serialize() : void 0) || JSON.parse(JSON.stringify(this.data))
        };
      }
      return format(this, [], (typeof (base1 = this.data).serialize === "function" ? base1.serialize() : void 0) || JSON.parse(JSON.stringify(this.data)));
    };

    Leaf.prototype.deserialize = function(data) {
      this.data = data;
      return this;
    };

    Leaf.prototype.getChildren = function() {
      return [];
    };

    Leaf.prototype.addChild = function() {
      throw new Error("JSUtils.Leaf::addChild: Cannot add a child to a leaf!");
    };

    Leaf.prototype.addChildren = function() {
      throw new Error("JSUtils.Leaf::addChildren: Cannot add children to a leaf!");
    };

    Leaf.prototype.setChildren = function() {
      throw new Error("JSUtils.Leaf::setChildren: Cannot set children of a leaf!");
    };

    Leaf.prototype.removeChild = function() {
      throw new Error("JSUtils.Leaf::removeChild: Cannot remove children of a leaf!");
    };

    Leaf.prototype.removeChildAt = function(idx) {
      throw new Error("JSUtils.Leaf::removeChildAt: Cannot remove children of a leaf!");
    };

    Leaf.prototype.adjustLevels = function() {
      return this;
    };

    return Leaf;

  })(JSUtils.Tree);

}).call(this);
