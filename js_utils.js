// Generated by CoffeeScript 1.10.0

/**
 * A class that executes asynchronous functions in an order.
 *
 * @example
 * `var seq = new Sequence([
 *     {
 *      func: () ->
 *          return true
 *      scope: someObject
 *      params: [1,2,3]
 *     }
 *     {
 *      func: () ->
 *          return new App.Sequence(...)
 *      scope: someObject
 *      params: (prevRes, presFunc, prevParams, idx) ->
 *          return [...]
 *     }
 *     [
 *      () -> return true,
 *      someObject,
 *      [1,2,3]
 *     ]
 * ])`
 *
 * Each asynchronous function MUST return an object that implements a `done()` method!
 *
 * This `done()` method takes 1 callback function as parameter (not like jQuery which can take multiple and arrays)! If parameters are to be passed to the callback, take care of it yourself (closuring?!).
 * When using `done()` callbacks in that asynchronous function those callbacks MUST be synchronous to make sure the order remains correct.
 *
 * @class Sequence
 * @extends Object
 * @constructor
 * @param data {Array}
 * Each element of that array is either an object like `{func: ..., scope: ..., params: ...}` and an array with the same values in that order.
 * For each element applies:
 * 'func' (or the 1st array element) is the function being executed.
 * 'scope' (or the 2nd element) is an object that serves as `this` in 'func'.
 * 'params' (or the 3rd element) is either
 * an array of parameters being passed to 'func'
 * or a function that creates such an array. In that case that function must have the form:
 * `(resultOfPreviouslyExecutedFunction, parametersOfPreviousCallback, previouslyExecutedFunction, scopeOfPreviouslyExecutedFunction, parametersOfPreviouslyExecutedFunction, indexInExecutionList) ->
 *     params = [...do stuff...]
 *     return params`
 * See the example or the static `test()` method for details.
 * @param start {Boolean}
 * Optional. Default is `true`. If it's `!== true` the Sequence will not start automatically. The `start()` method can be used to start it whenever.
*
 */

(function() {
  var arrEquals, arrayProtoDefs, fn, funcForArgs, idx, indexProps, key, len1, m, oldWrapAll, prop, val,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  App.Sequence = (function() {
    Sequence.PARAM_MODES = {
      CONTEXT: "CONTEXT",
      IMPLICIT: "IMPLICIT",
      EXPLICIT: "EXPLICIT"
    };


    /**
    * This method does the same as window.setTimeout() but makes it useable by App.Sequence. It also takes an additional (optional) scope parameter.
    * Basically window.setTimeout() is used in order to delay a whole Sequence.
    *
    * The mechanism is lik so:
    * An empty Sequence is created and returned (after it returns the `done()` callback is added by the Sequence itself).
    * The empty Sequence is delayed by 'delay' (with the help of window.setTimeout()) and when before it starts the passed function 'func', 'scope', and all 'params' passed to the Sequence.
    * @static
    * @method setTimeout
    * @param {Function|String} func
    * This parameter is either a function or a code string.
    * @param {Integer} delay
    * @param {Function} scope
    * @param {mixed} param1
    * @param {mixed} param2
    * @param ...
    *
     */

    function Sequence(data, start, stopOnError) {
      if (data == null) {
        data = [];
      }
      if (start == null) {
        start = true;
      }
      if (stopOnError == null) {
        stopOnError = true;
      }
      this.data = data;
      this.idx = 0;
      this.stopOnError = stopOnError;
      this._doneCallbacks = [];
      this._startCallback = null;
      this._endCallback = null;
      this._isDone = false;
      this._isStopped = false;
      this._parameterMode = this.constructor.PARAM_MODES.EXPLICIT;
      if (start === true) {
        this.start();
      }
    }


    /**
    * This method starts the Sequence in case it has been created with `false` as start parameter.
    * @method start
    * @param newData {Array}
    * Optional. If an array is given it will replace the possibly previously set data.
    * @return This istance. {Sequence}
    * @chainable
    *
     */

    Sequence.prototype.start = function(newData) {
      if (newData instanceof Array) {
        this.data = newData;
      }
      if (typeof this._startCallback === "function") {
        this._startCallback();
      }
      this._invokeNextFunction();
      return this;
    };

    Sequence.prototype._createParamListFromContext = function(func, context) {
      var argName, len1, m, paramList, temp;
      if (!(context instanceof Array)) {
        paramList = func.toString().split(/[()]/g).second.split(/\s*,\s*/g);
        temp = [];
        for (m = 0, len1 = paramList.length; m < len1; m++) {
          argName = paramList[m];
          temp.push(context[argName]);
        }
        return temp;
      }
      return context.slice(0);
    };


    /**
    * This method invokes the next function in the list.
    * @protected
    * @method _invokeNextFunction
    * @param previousReult {mixed}
    * The result the previously executed function returned or `null`.
    * @param args... {mixed}
    * These are the arguments passed to the callback itself.
    * @return This istance. {Sequence}
    * @chainable
    *
     */

    Sequence.prototype._invokeNextFunction = function() {
      var CLASS, args, d, data, error, error1, func, newParams, params, ref, ref1, res, scope, self;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this._isStopped) {
        return this;
      }
      data = this.data[this.idx];
      if (data != null) {
        if (data instanceof Array) {
          func = data[0];
          scope = data[1];
          params = data[2];
        } else {
          func = data.func;
          scope = data.scope;
          params = data.params;
        }
        if (func != null) {
          CLASS = this.constructor;
          self = this;
          if (params instanceof Array && params.length > 0) {
            this._parameterMode = CLASS.PARAM_MODES.EXPLICIT;
          }
          if (this._parameterMode === CLASS.PARAM_MODES.CONTEXT) {
            newParams = this._createParamListFromContext(func, args[0].context);
          } else if (this._parameterMode === CLASS.PARAM_MODES.EXPLICIT) {
            newParams = params;
          } else if (this._parameterMode === CLASS.PARAM_MODES.IMPLICIT) {
            newParams = args;
          }
          if (params instanceof Function) {
            d = this.data[this.idx - 1];
            newParams = params(args, {
              func: (d != null ? d.func : void 0) || (d != null ? d[0] : void 0),
              scope: (d != null ? d.scope : void 0) || (d != null ? d[1] : void 0) || null,
              params: (d != null ? (ref = d.params) != null ? ref.slice(0) : void 0 : void 0) || (d != null ? (ref1 = d[2]) != null ? ref1.slice(0) : void 0 : void 0) || []
            }, this.idx);
          }
          try {
            res = func.apply(scope || window, newParams);
          } catch (error1) {
            error = error1;
            res = null;
            console.error("=================================================================");
            console.error("App.Sequence::_invokeNextFunction: Given function (at index " + this.idx + ") threw an Error!");
            console.warn("Here is the data:", data);
            console.warn("Here is the error:", error);
            console.error("=================================================================");
            if (this.stopOnError) {
              this.interrupt();
            }
          }
          if (((res != null ? res.done : void 0) != null) && ((res != null ? res.context : void 0) != null)) {
            res.done.done(function() {
              self.idx++;
              self._parameterMode = CLASS.PARAM_MODES.CONTEXT;
              return self._invokeNextFunction(res);
            });
          } else if ((res != null ? res.done : void 0) != null) {
            res.done(function() {
              self.idx++;
              self._parameterMode = CLASS.PARAM_MODES.IMPLICIT;
              return self._invokeNextFunction.apply(self, arguments);
            });
          } else if (res != null ? res.context : void 0) {
            this.idx++;
            this._parameterMode = CLASS.PARAM_MODES.CONTEXT;
            this._invokeNextFunction(res);
          } else {
            this.idx++;
            this._parameterMode = CLASS.PARAM_MODES.IMPLICIT;
            this._invokeNextFunction(res);
          }
        }
      } else {
        this.lastResult = args[0];
        if (this._parameterMode === this.constructor.PARAM_MODES.CONTEXT) {
          this.lastResult = this.lastResult.context;
        }
        if (typeof this._endCallback === "function") {
          this._endCallback();
        }
        this._execDoneCallbacks();
      }
      return this;
    };


    /**
    * This method is called when the Sequence has executed all of its functions. It will then start executing all callbacks that previously have been added via `done()` (in the order they were added). No callback receives any parameters.
    * @protected
    * @method _execDoneCallbacks
    * @return This istance. {Sequence}
    * @chainable
    *
     */

    Sequence.prototype._execDoneCallbacks = function() {
      var cb, len1, m, ref;
      this._isDone = true;
      ref = this._doneCallbacks;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        cb = ref[m];
        cb();
      }
      return this;
    };

    Sequence.prototype.stop = function(execCallbacks) {
      if (execCallbacks == null) {
        execCallbacks = true;
      }
      this._isStopped = true;
      if (execCallbacks) {
        if (typeof this._endCallback === "function") {
          this._endCallback();
        }
        this._execDoneCallbacks();
      }
      return this;
    };

    Sequence.prototype.interrupt = function() {
      return this.stop(false);
    };

    Sequence.prototype.resume = function() {
      this._isStopped = false;
      this._invokeNextFunction();
      return this;
    };


    /**
    * Callback that gets called before the queue is being processed.
    * @method onStart
    *
     */

    Sequence.prototype.onStart = function() {
      var args, callback, context;
      callback = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof callback === "function") {
        this._startCallback = function() {
          return callback.apply(context, args);
        };
      }
      return this;
    };


    /**
    * Callback that gets called after the queue is processed but before the done callbacks are triggered.
    * @method onEnd
    *
     */

    Sequence.prototype.onEnd = function() {
      var args, callback, context;
      callback = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof callback === "function") {
        this._endCallback = function() {
          return callback.apply(context, args);
        };
      }
      return this;
    };


    /**
    * This method adds a callback that will be executed after all functions have returned.
    * @method done
    * @param callback {Function}
    * A function (without parameters).
    * @param context {Object}
    * @param args... {Function}
    * Arguments to be passed to the callback function.
    * @return This istance. {Sequence}
    * @chainable
    *
     */

    Sequence.prototype.done = function() {
      var args, callback, context, self;
      callback = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof callback === "function") {
        self = this;
        if (!this._isDone) {
          this._doneCallbacks.push(function() {
            return callback.apply(context, args.concat([self.lastResult]));
          });
        } else {
          callback.apply(context, args.concat([self.lastResult]));
        }
      }
      return this;
    };

    Sequence.prototype.then = Sequence.prototype.done;


    /**
    * This method returns the progress of the Sequence in [0,1].
    * @method getProgress
    * @return progress {Number}
    *
     */

    Sequence.prototype.progress = function() {
      return this.idx / this.data.length;
    };


    /**
    * @method while
    * @return {Sequence}
    * @chainable
    *
     */

    Sequence.prototype["while"] = function(startFunc, endFunc, context, args) {
      this.onStart(startFunc, context, args);
      this.onEnd(endFunc, context, args);
      return this;
    };

    return Sequence;

  })();

  if (DEBUG) {
    App.Sequence.test = function() {
      var sequence;
      return sequence = new App.Sequence([
        {
          func: function(id, idx) {
            console.log("func1! idx = " + idx + (idx != null ? " (called again...so actually func2 ^^)" : ""));
            return this.get("http://localhost:3000/api/report/" + id);
          },
          scope: $,
          params: [12]
        }, {
          func: function(response) {
            console.log("jquery get callback:", response);
            return response;
          }
        }, {
          func: function(response) {
            console.log("next seq function with prev result:", response);
            return true;
          }
        }
      ], false)["while"](loadingIndicator.start, loadingIndicator.stop, loadingIndicator).start();
    };
  }


  /**
  * A class that starts executing asynchronous functions and waits for them to finish.
  *
  * @example
  * `var barrier = new Barrier([
  *     {
  *      func: () ->
  *          return true
  *      scope: someObject
  *      params: [1,2,3]
  *     }
  *     {
  *      func: () ->
  *          return new App.Sequence(...)
  *      scope: someObject
  *     [
  *      () -> return true,
  *      someObject,
  *      [1,2,3]
  *     ]
  * ])`
  *
  * Each asynchronous function MUST return an object that implements a `done()` method!
  *
  * This `done()` method takes 1 callback function as parameter (not like jQuery which can take multiple and arrays)! If parameters are to be passed to the callback, take care of it yourself (closuring?!).
  * When using `done()` callbacks in that asynchronous function those callbacks MUST be synchronous to make sure the order remains correct.
  *
  * @class Barrier
  * @extends Object
  * @constructor
  * @param data {Array}
  * Each element of that array is either an object like `{func: ..., scope: ..., params: ...}` and an array with the same values in that order.
  * For each element applies:
  * 'func' (or the 1st array element) is the function being executed.
  * 'scope' (or the 2nd element) is an object that serves as `this` in 'func'.
  * 'params' (or the 3rd element) is an array of parameters being passed to 'func'
  * or a function that creates such an array. In that case that function must have the form:
  * @param start {Boolean}
  * Optional. Default is `true`. If it's `!== true` the Sequence will not start automatically. The `start()` method can be used to start it whenever.
  *
   */

  App.Barrier = (function() {
    Barrier.forArray = function(array, callback, start) {
      var data, elem, len1, m;
      if (array == null) {
        array = [];
      }
      if (start == null) {
        start = true;
      }
      data = [];
      for (m = 0, len1 = array.length; m < len1; m++) {
        elem = array[m];
        data.push({
          func: (function(elem) {
            return function() {
              return callback(elem);
            };
          })(elem)
        });
      }
      return new App.Barrier(data, start);
    };

    function Barrier(data, start) {
      if (data == null) {
        data = [];
      }
      if (start == null) {
        start = true;
      }
      this.data = data;
      this.remainingThreads = data.length;
      this.funcResults = [];
      this._doneCallbacks = [];
      this._startCallback = null;
      this._endCallback = null;
      this._endAllCallback = null;
      this._isDone = false;
      this._isStopped = false;
      this._sequences = [];
      if (start === true) {
        this.start();
      }
    }


    /**
    * This method starts the Barrier in case it has been created with `false` as start parameter.
    * @method start
    * @param newData {Array}
    * Optional. If an array is given it will replace the possibly previously set data.
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype.start = function(newData) {
      var d, idx, len1, m, ref;
      if (newData instanceof Array) {
        this.data = newData;
        this.remainingThreads = newData.length;
      }
      if (typeof this._startCallback === "function") {
        this._startCallback();
      }
      if (this.remainingThreads > 0) {
        ref = this.data;
        for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
          d = ref[idx];
          if (d != null) {
            this._invokeNextFunction(d, idx);
          }
        }
      } else {
        this._funcDone();
      }
      return this;
    };


    /**
    * This method invokes the next function in the list.
    * @protected
    * @method _invokeNextFunction
    * @param data {Object|Array}
    * Function data (same structure as in App.Sequence)
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype._invokeNextFunction = function(data, idx) {
      var func, params, scope;
      if (this._isStopped) {
        return this;
      }
      func = data.func || data[0];
      scope = data.scope || data[1];
      params = data.params || data[2];
      this._sequences.push(new App.Sequence([
        {
          func: function() {
            var error, error1;
            try {
              return func.apply(scope, params);
            } catch (error1) {
              error = error1;
              return error;
            }
          }
        }, {
          func: function(prevResOrResponse) {
            this.funcResults[idx] = prevResOrResponse;
            this._funcDone();
            return this;
          },
          scope: this
        }
      ]));
      return this;
    };

    Barrier.prototype._funcDone = function() {
      console.log("barrier: decrementing remainingThreads from " + this.remainingThreads + " to " + (this.remainingThreads - 1));
      if (--this.remainingThreads <= 0) {
        this._isDone = true;
        if (typeof this._endCallback === "function") {
          this._endCallback();
        }
        this._execDoneCallbacks();
        if (typeof this._endAllCallback === "function") {
          this._endAllCallback();
        }
      }
      return this;
    };


    /**
    * This method adds a callback that will be executed after all functions have returned.
    * @method done
    * @param callback {Function}
    * A function (without parameters).
    * @param context {Object}
    * @param args... {Function}
    * Arguments to be passed to the callback function.
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype.done = function() {
      var args, callback, context, self;
      callback = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof callback === "function") {
        self = this;
        if (!this._isDone) {
          this._doneCallbacks.push(function() {
            return callback.apply(context, args.concat([self.funcResults]));
          });
        } else {
          callback.apply(context, args.concat([self.funcResults]));
        }
      }
      return this;
    };

    Barrier.prototype.then = Barrier.prototype.done;


    /**
    * This method returns the progress (how many async function have already reached the Barrier) in [0,1].
    * @method getProgress
    * @return progress {Number}
    *
     */

    Barrier.prototype.getProgress = function() {
      return 1 - this.remainingThreads / this.data.length;
    };


    /**
    * This method is called when the Sequence has executed all of its functions. It will then start executing all callbacks that previously have been added via `done()` (in the order they were added). No callback receives any parameters.
    * @protected
    * @method _execDoneCallbacks
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype._execDoneCallbacks = function() {
      var cb, len1, m, ref;
      ref = this._doneCallbacks;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        cb = ref[m];
        cb();
      }
      return this;
    };


    /**
    * This method sets the start and end callback that are executed before the Barrier starts and after it's done (but before the done callbacks are being executed).
    * @protected
    * @method while
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype["while"] = function(startCallback, endCallback, context) {
      if (context != null) {
        this._startCallback = function() {
          return context.startCallback();
        };
        this._endCallback = function() {
          return context.endCallback();
        };
      } else {
        this._startCallback = startCallback;
        this._endCallback = endCallback;
      }
      return this;
    };


    /**
    * Same as while() but the 2nd parameter is executed AFTER the done callbacks.
    * @protected
    * @method whileAll
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype.whileAll = function(startCallback, endCallback, context) {
      if (context != null) {
        this._startCallback = function() {
          return context.startCallback();
        };
        this._endAllCallback = function() {
          return context.endCallback();
        };
      } else {
        this._startCallback = startCallback;
        this._endAllCallback = endCallback;
      }
      return this;
    };

    Barrier.prototype.stop = function(execCallbacks) {
      var len1, m, ref, sequence;
      if (execCallbacks == null) {
        execCallbacks = true;
      }
      this._isStopped = true;
      ref = this._sequences;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        sequence = ref[m];
        sequence.stop(execCallbacks);
      }
      if (execCallbacks) {
        if (typeof this._endCallback === "function") {
          this._endCallback();
        }
        this._execDoneCallbacks();
      }
      return this;
    };

    Barrier.prototype.interrupt = function() {
      return this.stop(false);
    };

    Barrier.prototype.resume = function() {
      this._isStopped = false;
      this._invokeNextFunction();
      return this;
    };

    return Barrier;

  })();

  App.Doneable = new App.Sequence();


  /**
   * This is an implementation of a dictionary/hash that does not convert its keys into Strings. Keys can therefore actually by anything! :)
   * @class Configurator
   * @constructor
  *
   */

  App.Hash = (function() {

    /**
     * Creates a new Hash from a given JavaScript object.
     * @static
     * @method fromObject
     * @param object {Object}
    *
     */
    var _putObject;

    Hash.fromObject = function(obj) {
      var hash, key, val;
      hash = new App.Hash();
      for (key in obj) {
        val = obj[key];
        hash.put(key, val);
      }
      return hash;
    };

    function Hash(obj, defaultVal, equality) {
      var key, val;
      if (defaultVal == null) {
        defaultVal = null;
      }
      this.keys = [];
      this.values = [];
      this.equality = equality;
      if (obj != null) {
        for (key in obj) {
          val = obj[key];
          this.put(key, val);
        }
      }
    }

    Hash.prototype.toObject = function() {
      var idx, key, len1, m, ref, res;
      res = {};
      ref = this.keys;
      for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
        key = ref[idx];
        res[key] = this.values[idx];
      }
      return res;
    };

    Hash.prototype.clone = function() {
      var res;
      res = new App.Hash();
      res.keys = this.keys.clone();
      res.values = this.values.clone();
      return res;
    };

    Hash.prototype.invert = function() {
      var res;
      res = new App.Hash();
      res.keys = this.values.clone();
      res.values = this.keys.clone();
      return res;
    };


    /**
     * Adds a new key-value pair or overwrites an existing one.
     * @private
     * @method _putObject
     * @param object {Object}
     * @return {Hash} This instance.
     * @chainable
    *
     */

    _putObject = function(obj) {
      var key, val;
      for (key in obj) {
        val = obj[key];
        this.put(key, val);
      }
      return this;
    };


    /**
     * Return the index of the given key
     * @method findKeyIdx
     * @param key {mixed}
     * @return {Hash} This instance.
     * @chainable
    *
     */

    Hash.prototype.findKeyIdx = function(key) {
      var el, idx, len1, m, ref;
      ref = this.keys;
      for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
        el = ref[idx];
        if ((typeof this.equality === "function" ? this.equality(el, key) : void 0) || el === key) {
          return idx;
        }
      }
      return -1;
    };


    /**
     * Adds a new key-value pair or overwrites an existing one.
     * @method put
     * @param key {mixed}
     * @param val {mixed}
     * @return {Hash} This instance.
     * @chainable
    *
     */

    Hash.prototype.put = function(key, val) {
      var idx;
      if (val == null) {
        return _putObject.call(this, key);
      }
      idx = this.findKeyIdx(key);
      if (idx < 0) {
        this.keys.push(key);
        this.values.push(val);
      } else {
        this.keys[idx] = key;
        this.values[idx] = val;
      }
      return this;
    };


    /**
     * Adds a new key-value pair or overwrites an existing one.
     * @method putMultiple
     * @param pairs... {mixed}
     * @param val {mixed}
     * @return {Hash} This instance.
     * @chainable
    *
     */

    Hash.prototype.putMultiple = function() {
      var idx, key, len1, m, pairs, ref, val;
      pairs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      for (m = 0, len1 = pairs.length; m < len1; m++) {
        ref = pairs[m], key = ref[0], val = ref[1];
        if (val == null) {
          _putObject.call(this, key);
        }
        idx = this.findKeyIdx(key);
        if (idx < 0) {
          this.keys.push(key);
          this.values.push(val);
        } else {
          idx = this.keys.indexOf(key);
          if (idx < 0) {
            this.keys.push(key);
            this.values.push(val);
          } else {
            this.keys[idx] = key;
            this.values[idx] = val;
          }
        }
      }
      return this;
    };


    /**
     * Returns the value (or null) for the specified key.
     * @method get
     * @param key {mixed}
     * @param [equalityFunction] {Function}
     * This optional function can overwrite the test for equality between keys. This function expects the parameters: (the current key in the key iteration, 'key'). If this parameters is omitted '===' is used.
     * @return {mixed}
    *
     */

    Hash.prototype.get = function(key, eqFunc) {
      var i, idx, k;
      if (eqFunc == null) {
        idx = this.findKeyIdx(key);
      } else {
        idx = ((function() {
          var len1, m, ref, results;
          ref = this.keys;
          results = [];
          for (i = m = 0, len1 = ref.length; m < len1; i = ++m) {
            k = ref[i];
            if (eqFunc(k, key) === true) {
              results.push(i);
            }
          }
          return results;
        }).call(this)).first;
      }
      if (idx >= 0) {
        return this.values[idx];
      }
      return (typeof this.defaultVal === "function" ? this.defaultVal() : void 0) || this.defaultVal;
    };


    /**
     * Returns a list of all key-value pairs. Each pair is an Array with the 1st element being the key, the 2nd being the value.
     * @method getAll
     * @return {Array} Key-value pairs.
    *
     */

    Hash.prototype.getAll = function() {
      var idx, key, len1, m, ref, res;
      res = [];
      ref = this.keys;
      for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
        key = ref[idx];
        res.push([key, this.values[idx]]);
      }
      return res;
    };


    /**
     * Indicates whether the Hash has the specified key.
     * @method hasKey
     * @param key {mixed}
     * @return {Boolean}
    *
     */

    Hash.prototype.hasKey = function(key) {
      return this.findKeyIdx(key) >= 0;
    };

    Hash.prototype.has = Hash.prototype.hasKey;


    /**
     * Returns the number of entries in the Hash.
     * @method size
     * @return {Integer}
    *
     */

    Hash.prototype.size = function() {
      return this.keys.length;
    };


    /**
     * Returns all the keys of the Hash.
     * @method getKeys()
     * @return {Array}
    *
     */

    Hash.prototype.getKeys = function() {
      return this.keys;
    };


    /**
     * Returns all the values of the Hash.
     * @method getValues()
     * @return {Array}
    *
     */

    Hash.prototype.getValues = function() {
      return this.values;
    };


    /**
     * Returns a list of keys that have val (or anything equal as specified in 'eqFunc') as value.
     * @method getKeysForValue
     * @param val {mixed}
     * @param [equalityFunction] {Function}
     * This optional function can overwrite the test for equality between values. This function expects the parameters ('value' and the current value in the value iteration). If this parameters is omitted '===' is used.
     * @return {mixed}
    *
     */

    Hash.prototype.getKeysForValue = function(value, eqFunc) {
      var idx, idxs, val;
      if (eqFunc == null) {
        idxs = (function() {
          var len1, m, ref, results;
          ref = this.values;
          results = [];
          for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
            val = ref[idx];
            if (this.equality(val, value) || val === value) {
              results.push(idx);
            }
          }
          return results;
        }).call(this);
      } else {
        idxs = (function() {
          var len1, m, ref, results;
          ref = this.values;
          results = [];
          for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
            val = ref[idx];
            if (eqFunc(val, value) === true) {
              results.push(idx);
            }
          }
          return results;
        }).call(this);
      }
      return (function() {
        var len1, m, results;
        results = [];
        for (m = 0, len1 = idxs.length; m < len1; m++) {
          idx = idxs[m];
          results.push(this.keys[idx]);
        }
        return results;
      }).call(this);
    };

    Hash.prototype.empty = function() {
      this.keys = [];
      this.values = [];
      return this;
    };

    Hash.prototype.remove = function(key) {
      var idx;
      idx = this.keys.indexOf(key);
      if (idx >= 0) {
        this.keys.splice(idx, 1);
        this.values.splice(idx, 1);
      } else {
        console.warn("Could not remove key '" + key + "'!");
      }
      return this;
    };

    Hash.prototype.each = function(callback) {
      var i, key, len1, m, ref;
      ref = this.keys;
      for (i = m = 0, len1 = ref.length; m < len1; i = ++m) {
        key = ref[i];
        if (callback(key, this.values[i], i) === false) {
          return this;
        }
      }
      return this;
    };

    return Hash;

  })();

  arrEquals = function(arr1, arr2) {
    var i, len1, m, x;
    if (arr1.length !== arr2.length) {
      return false;
    }
    for (i = m = 0, len1 = arr1.length; m < len1; i = ++m) {
      x = arr1[i];
      if (x !== arr2[i]) {
        return false;
      }
    }
    return true;
  };

  funcForArgs = function(args, argLists, funcs) {
    var arg, argList, argListToCheck, i, lastMatchedIdx, len1, m;
    argListToCheck = (function() {
      var len1, m, results;
      results = [];
      for (m = 0, len1 = args.length; m < len1; m++) {
        arg = args[m];
        results.push(arg.constructor);
      }
      return results;
    })();
    for (i = m = 0, len1 = argLists.length; m < len1; i = ++m) {
      argList = argLists[i];
      if (arrEquals(argList, argListToCheck)) {
        return funcs[i] || funcs[lastMatchedIdx];
      }
      lastMatchedIdx = i;
    }
    return null;
  };

  window.jOverload = function() {
    var arg, argList, argLists, args, funcs, i, j, k, len, m, name, ref, type;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    argLists = [];
    funcs = [];
    i = 0;
    len = args.length;
    while (i < len) {
      j = i;
      while (!((argList = args[j]) instanceof Function) && j < len) {
        if (!(argList instanceof Array)) {
          argLists.push((function() {
            var results;
            results = [];
            for (name in argList) {
              type = argList[name];
              results.push(type);
            }
            return results;
          })());
        } else {
          argLists.push(argList);
        }
        j++;
      }
      if (j < len) {
        funcs.push(args[j]);
        for (k = m = 0, ref = j - i - 1; 0 <= ref ? m < ref : m > ref; k = 0 <= ref ? ++m : --m) {
          funcs.push(null);
        }
        i = j + 1;
      } else {
        throw new Error("No function given for argument lists: " + (JSON.stringify((function() {
          var len1, o, ref1, results;
          ref1 = args.slice(i);
          results = [];
          for (o = 0, len1 = ref1.length; o < len1; o++) {
            argList = ref1[o];
            results.push((function() {
              var len2, p, results1;
              results1 = [];
              for (p = 0, len2 = argList.length; p < len2; p++) {
                arg = argList[p];
                results1.push(arg.name);
              }
              return results1;
            })());
          }
          return results;
        })())));
      }
    }
    return function() {
      var f;
      if ((f = funcForArgs(arguments, argLists, funcs)) != null) {
        return f.apply(this, arguments);
      }
      throw new Error("Arguments do not match any known argument list!");
    };
  };

  Math.sign = function(n) {
    if (n != null) {
      if (n < 0) {
        return -1;
      }
      return 1;
    }
    return 0;
  };

  Math.isNum = function(n) {
    return (n != null) && isFinite(n);
  };

  Math.average = function() {
    var elem, elems, len1, m, sum, vals;
    vals = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (vals[0] instanceof Array) {
      vals = vals[0];
    }
    sum = 0;
    elems = 0;
    for (m = 0, len1 = vals.length; m < len1; m++) {
      elem = vals[m];
      if (!(Math.isNum(elem))) {
        continue;
      }
      sum += elem;
      elems++;
    }
    return sum / elems;
  };

  Math.log10 = function(x) {
    if ((x != null) && x > 0) {
      return Math.log(x) / Math.LN10;
    }
    return void 0;
  };

  Math.roundToSig = function(num, digits) {
    return parseFloat(num.toPrecision(digits));
  };

  Math.toSig = function(num, digits, separator) {
    var format, i, rounded, roundedDigits;
    if (separator == null) {
      separator = "";
    }
    rounded = Math.roundToSig(num, digits);
    roundedDigits = ("" + rounded).replace("\.", "").length;
    if (roundedDigits < digits || ~~rounded !== rounded) {
      format = "0." + (((function() {
        var m, ref, results;
        results = [];
        for (i = m = 0, ref = Math.abs(digits - roundedDigits); 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
          results.push("0");
        }
        return results;
      })()).join(""));
    } else {
      format = "0";
    }
    return numeral(rounded).format(format);
  };

  Function.prototype.clone = function() {
    var that = this;
    var temp = function temporary() { return that.apply(this, arguments); };
    for( key in this ) {
        temp[key] = this[key];
    }
    return temp;
};

  Object.except = function() {
    var k, keys, obj, res, v;
    obj = arguments[0], keys = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (keys.first instanceof Array) {
      keys = keys.first;
    }
    keys = keys.concat(Object.keys(obj.__proto__));
    res = {};
    for (k in obj) {
      v = obj[k];
      if (indexOf.call(keys, k) < 0) {
        res[k] = v;
      }
    }
    res.__proto__ = obj.__proto__;
    return res;
  };

  Object.values = function(obj) {
    var k, res, v;
    if (DEBUG) {
      if (!(obj instanceof Object)) {
        throw new Error("Called non-object: " + obj);
      }
    }
    res = [];
    for (k in obj) {
      v = obj[k];
      res.push(v);
    }
    return res;
  };

  Object.values = function(obj) {
    var key, val;
    if (DEBUG) {
      if (!(obj instanceof Object)) {
        throw new Error("Called non-object: " + obj);
      }
    }
    return (function() {
      var results;
      results = [];
      for (key in obj) {
        val = obj[key];
        results.push(val);
      }
      return results;
    })();
  };

  Object.swapKeys = function() {
    var i, key1, key2, keys, m, obj, ref, temp;
    obj = arguments[0], keys = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (keys.length % 2 === 0) {
      for (i = m = 0, ref = keys.length; m < ref; i = m += 2) {
        key1 = keys[i];
        key2 = keys[i + 1];
        temp = obj[key1];
        obj[key1] = obj[key2];
        obj[key2] = temp;
      }
    }
    return obj;
  };

  if (Element.prototype.remove == null) {
    Element.prototype.remove = function() {
      return this.parentNode.removeChild(this);
    };
  }

  String.prototype.replaceMultiple = function(array, mode) {
    var cbFun, i, length, m, modes, needle, o, ref, ref1, repl, temp;
    if ((array == null) || array.length < 2) {
      return this;
    }
    length = array.length;
    modes = {
      0: 0,
      tuples: 0,
      1: 1,
      diffByOne: 1,
      2: 2,
      oneByDiff: 2
    };
    mode = modes[mode];
    if (mode == null) {
      mode = 0;
    }
    temp = this;
    if (mode === 0) {
      if (length & 1) {
        return this;
      }
      for (i = m = 0, ref = length; m < ref; i = m += 2) {
        temp = temp.replace(array[i], array[i + 1]);
      }
    }
    if (mode === 1) {
      repl = array[length - 1];
      for (i = o = 0, ref1 = length - 1; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
        temp = temp.replace(array[i], repl);
      }
    }
    if (mode === 2) {
      if (length !== 2) {
        return this;
      }
      needle = array.first;
      cbFun = array.second;
      i = 0;
      while (temp.indexOf(needle) !== -1 && i < length) {
        temp = temp.replace(needle, cbFun(i));
        i++;
      }
    }
    return temp;
  };

  String.prototype.unCamelCase = function() {
    return this.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/\b([A-Z]+)([A-Z])([a-z])/, '$1-$2$3').toLowerCase();
  };

  String.prototype.firstToUpperCase = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
  };

  String.prototype.firstToLowerCase = function() {
    return this.charAt(0).toLowerCase() + this.slice(1);
  };

  String.prototype.snakeToCamelCase = function() {
    var char, len1, m, prevChar, res;
    res = "";
    for (m = 0, len1 = this.length; m < len1; m++) {
      char = this[m];
      if (char !== "_") {
        if (prevChar !== "_") {
          res += char;
        } else {
          res += char.toUpperCase();
        }
      }
      prevChar = char;
    }
    return res;
  };

  String.prototype.camelToSnakeCase = function() {
    var char, len1, m, prevChar, res;
    res = "";
    prevChar = null;
    for (m = 0, len1 = this.length; m < len1; m++) {
      char = this[m];
      if (char === char.toLowerCase()) {
        res += char;
      } else {
        if (prevChar) {
          res += "_" + char.toLowerCase();
        } else {
          res += char.toLowerCase();
        }
      }
      prevChar = char;
    }
    return res;
  };

  String.prototype.lower = String.prototype.toLowerCase;

  String.prototype.upper = String.prototype.toUpperCase;

  String.prototype.isNumeric = function() {
    return Math.isNum(parseFloat(this));
  };

  String.prototype.endsWith = function(end) {
    var index;
    index = this.lastIndexOf(end);
    if (index >= 0) {
      return index + end.length === this.length;
    }
    return false;
  };

  String.prototype.times = function(n) {
    var i, m, ref, res;
    if (n == null) {
      n = 1;
    }
    res = "";
    for (i = m = 0, ref = n; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
      res += this;
    }
    return res;
  };

  String.prototype.encodeHTMLEntities = function() {
    return this.replace(/[\u00A0-\u9999<>\&]/gim, function(i) {
      return "&#" + (i.charCodeAt(0)) + ";";
    });
  };

  Array.prototype.unique = function() {
    var elem, len1, m, res;
    res = [];
    for (m = 0, len1 = this.length; m < len1; m++) {
      elem = this[m];
      if (indexOf.call(res, elem) < 0) {
        res.push(elem);
      }
    }
    return res;
  };

  Array.prototype.uniqueBy = function(propGetter, equals) {
    var done, duplicate, elem, len1, len2, m, o, res;
    if (propGetter == null) {
      propGetter = function(item) {
        return item;
      };
    }
    if (equals == null) {
      equals = function(a, b) {
        return a === b;
      };
    }
    res = [];
    for (m = 0, len1 = this.length; m < len1; m++) {
      elem = this[m];
      duplicate = false;
      for (o = 0, len2 = res.length; o < len2; o++) {
        done = res[o];
        if (!(equals(propGetter(done), propGetter(elem)))) {
          continue;
        }
        duplicate = true;
        break;
      }
      if (!duplicate) {
        res.push(elem);
      }
    }
    return res;
  };

  Array.prototype.intersect = function(arr) {
    var elem;
    arr = arr;
    return ((function() {
      var len1, m, results;
      results = [];
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        if (indexOf.call(arr, elem) >= 0) {
          results.push(elem);
        }
      }
      return results;
    }).call(this)).unique();
  };

  Array.prototype.intersects = function(arr) {
    return this.intersect(arr).length > 0;
  };

  Array.prototype.groupBy = function(groupFun, equality) {
    var dict, elem, grouped, len1, m;
    dict = new App.Hash(null, equality);
    for (m = 0, len1 = this.length; m < len1; m++) {
      elem = this[m];
      grouped = groupFun(elem);
      if (dict.get(grouped) == null) {
        dict.put(grouped, []);
      }
      dict.get(grouped).push(elem);
    }
    return dict;
  };

  Array.prototype.insert = function() {
    var elements, index;
    index = arguments[0], elements = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    this.splice.apply(this, [index, 0].concat(slice.call(elements)));
    return this;
  };

  Array.prototype.remove = function() {
    var elem, elements;
    elements = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return (function() {
      var len1, m, results;
      results = [];
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        if (indexOf.call(elements, elem) < 0) {
          results.push(elem);
        }
      }
      return results;
    }).call(this);
  };

  Array.prototype.removeAt = function(idx) {
    this.splice(idx, 1);
    return this;
  };

  Array.prototype.elemMoved = function(fromIdx, toIdx) {
    var e, elem, i, len1, m, res;
    res = [];
    elem = this[fromIdx];
    for (i = m = 0, len1 = this.length; m < len1; i = ++m) {
      e = this[i];
      if (!(i !== fromIdx)) {
        continue;
      }
      res.push(e);
      if (i === toIdx) {
        res.push(elem);
      }
    }
    return res;
  };

  Array.prototype.flatten = function() {
    return Array.prototype.concat.apply([], this);
  };

  Array.prototype.clone = Array.prototype.slice;

  Array.prototype.cloneDeep = function() {
    var elem, i, len1, m;
    for (i = m = 0, len1 = this.length; m < len1; i = ++m) {
      elem = this[i];
      if (elem instanceof Array) {
        this[i] = elem.cloneDeep();
      }
    }
    return this.clone();
  };

  Array.prototype.except = function() {
    var el, vals;
    vals = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (vals.first instanceof Array) {
      vals = vals.first;
    }
    return (function() {
      var len1, m, results;
      results = [];
      for (m = 0, len1 = this.length; m < len1; m++) {
        el = this[m];
        if (indexOf.call(vals, el) < 0) {
          results.push(el);
        }
      }
      return results;
    }).call(this);
  };

  Array.prototype.without = Array.prototype.except;


  /**
  * Returns the first element that fulfills the condition in a recursive search.
  * @param condition {Function}
  * @param getSubArray {Function}
  * Optional. If given, it's used to retrieve the next (lower) array for recursion.
  * Default: Go deeper only on elements that are arrays themselves.
  *
   */

  Array.prototype.find = function(condition, getSubArray) {
    var item, len1, m, res, subArray;
    if (!(condition instanceof Function)) {
      condition = function(item) {
        return item === condition;
      };
    }
    if (getSubArray == null) {
      getSubArray = function(item) {
        return item;
      };
    }
    for (m = 0, len1 = this.length; m < len1; m++) {
      item = this[m];
      if (condition(item) === true) {
        return item;
      }
      if ((subArray = getSubArray(item)) instanceof Array) {
        if ((res = subArray.find(condition, getSubArray)) != null) {
          return res;
        }
      }
    }
    return null;
  };

  Array.prototype.binIndexOf = function(searchElement) {
    var currentElement, currentIndex, maxIndex, minIndex;
    minIndex = 0;
    maxIndex = this.length - 1;
    while (minIndex <= maxIndex) {
      currentIndex = Math.floor((minIndex + maxIndex) / 2);
      currentElement = this[currentIndex];
      if (currentElement < searchElement) {
        minIndex = currentIndex + 1;
      } else if (currentElement > searchElement) {
        maxIndex = currentIndex - 1;
      } else {
        return currentIndex;
      }
    }
    return -1;
  };

  Array.prototype.sortProp = function(getProp, order) {
    var cmpFunc;
    if (order == null) {
      order = "asc";
    }
    if (getProp == null) {
      getProp = function(item) {
        return item;
      };
    }
    if (order === "asc") {
      cmpFunc = function(a, b) {
        a = getProp(a);
        b = getProp(b);
        if (a < b) {
          return -1;
        }
        if (b < a) {
          return 1;
        }
        return 0;
      };
    } else {
      cmpFunc = function(a, b) {
        a = getProp(a);
        b = getProp(b);
        if (a > b) {
          return -1;
        }
        if (b > a) {
          return 1;
        }
        return 0;
      };
    }
    return this.sort(cmpFunc);
  };


  /**
   * @method getMax
   * @param {Function} propertyGetter
   * The passed callback extracts the value being compared from the array elements.
   * @return {Array} An array of all maxima.
  *
   */

  Array.prototype.getMax = function(propertyGetter) {
    var elem, len1, m, max, res, val;
    max = null;
    res = [];
    if (propertyGetter == null) {
      propertyGetter = function(item) {
        return item;
      };
    }
    for (m = 0, len1 = this.length; m < len1; m++) {
      elem = this[m];
      val = propertyGetter(elem);
      if (val > max || max === null) {
        max = val;
        res = [elem];
      } else if (val === max) {
        res.push(elem);
      }
    }
    return res;
  };

  Array.prototype.getMin = function(propertyGetter) {
    var elem, len1, m, min, res, val;
    min = null;
    res = [];
    if (propertyGetter == null) {
      propertyGetter = function(item) {
        return item;
      };
    }
    for (m = 0, len1 = this.length; m < len1; m++) {
      elem = this[m];
      val = propertyGetter(elem);
      if (val < min || min === null) {
        min = val;
        res = [elem];
      } else if (val === min) {
        res.push(elem);
      }
    }
    return res;
  };

  Array.prototype.reverseCopy = function() {
    var item;
    return (function() {
      var m, results;
      results = [];
      for (m = this.length - 1; m >= 0; m += -1) {
        item = this[m];
        results.push(item);
      }
      return results;
    }).call(this);
  };

  Array.prototype.sample = function(n, forceArray) {
    var arr, elem, i, res;
    if (n == null) {
      n = 1;
    }
    if (forceArray == null) {
      forceArray = false;
    }
    if (n === 1) {
      if (!forceArray) {
        return this[Math.floor(Math.random() * this.length)];
      }
      return [this[Math.floor(Math.random() * this.length)]];
    }
    if (n > this.length) {
      n = this.length;
    }
    i = 0;
    res = [];
    arr = this.clone();
    while (i++ < n) {
      elem = arr.sample(1);
      res.push(elem);
      arr.remove(elem);
    }
    return res;
  };

  Array.prototype.shuffle = function() {
    var arr, elem, i, len1, m;
    arr = this.sample(this.length);
    for (i = m = 0, len1 = arr.length; m < len1; i = ++m) {
      elem = arr[i];
      this[i] = elem;
    }
    return this;
  };

  Array.prototype.toObject = function(callback) {
    var elem, i, len1, len2, m, o, res;
    res = {};
    if (callback == null) {
      for (i = m = 0, len1 = this.length; m < len1; i = ++m) {
        elem = this[i];
        res[elem[0]] = elem[1];
      }
      return res;
    }
    for (i = o = 0, len2 = this.length; o < len2; i = ++o) {
      elem = this[i];
      elem = callback(elem);
      res[elem[0]] = elem[1];
    }
    return res;
  };

  Array.prototype.swap = function(i, j) {
    var tmp;
    tmp = this[i];
    this[i] = this[j];
    this[j] = tmp;
    return this;
  };

  Array.prototype.times = function(n) {
    var i, m, ref, res;
    res = this.clone();
    for (i = m = 1, ref = n; 1 <= ref ? m < ref : m > ref; i = 1 <= ref ? ++m : --m) {
      res = res.merge(this);
    }
    return res;
  };

  Array.prototype.prepend = Array.prototype.unshift;

  Array.prototype.append = Array.prototype.push;

  arrayProtoDefs = {
    and: {
      value: function(elem) {
        return this.concat([elem]);
      }
    },
    merge: {
      value: function(array) {
        Array.prototype.push.apply(this, array);
        return this;
      }
    },
    noNulls: {
      value: function() {
        var e, len1, m, res;
        res = [];
        for (m = 0, len1 = this.length; m < len1; m++) {
          e = this[m];
          if (e != null) {
            res.push(e);
          }
        }
        return res;
      }
    },
    average: {
      get: function() {
        return Math.average.apply(null, this);
      },
      set: function() {}
    },
    last: {
      get: function() {
        if (this.length > 0) {
          if ((typeof n !== "undefined" && n !== null) && n > 0) {
            return this.slice(-n);
          }
          return this[this.length - 1];
        }
        return void 0;
      },
      set: function(val) {
        this[this.length - 1] = val;
        return this;
      }
    },
    sum: {
      get: function() {
        var elem, len1, m, res;
        res = 0;
        for (m = 0, len1 = this.length; m < len1; m++) {
          elem = this[m];
          if (Math.isNum(elem)) {
            res += elem;
          }
        }
        return res;
      },
      set: function() {
        console.warn("[].sum is not settable!");
        return this;
      }
    }
  };

  indexProps = ["first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "forty-second"];

  fn = function(prop, idx) {
    return arrayProtoDefs[prop] = {
      get: function() {
        return this[idx];
      },
      set: function(val) {
        this[idx] = val;
        return this;
      }
    };
  };
  for (idx = m = 0, len1 = indexProps.length; m < len1; idx = ++m) {
    prop = indexProps[idx];
    fn(prop, idx);
  }

  for (key in arrayProtoDefs) {
    val = arrayProtoDefs[key];
    val.enumerable = false;
    val.configurable = false;
  }

  Object.defineProperties(Array.prototype, arrayProtoDefs);

  $.fn.content = function(n) {
    var children, text;
    if (n != null) {
      if (typeof n === "string") {
        children = this.children().detach();
        this.empty().append(n).append(children);
      }
      return this;
    } else {
      children = this.children().detach();
      text = this.text();
      this.append(children);
      return text;
    }
  };

  $.fn.toggleAttr = function(attr, val1, val2, css) {
    var elem, len2, o;
    for (o = 0, len2 = this.length; o < len2; o++) {
      elem = this[o];
      if (css === true) {
        if ($(elem).css(attr) === val1) {
          $(elem).css(attr, val2);
        } else {
          $(elem).css(attr, val1);
        }
      } else {
        if ($(elem).attr(attr) === val1) {
          $(elem).attr(attr, val2);
        } else {
          $(elem).attr(attr, val1);
        }
      }
    }
    return this;
  };

  $.fn.dimensions = function() {
    return {
      x: parseInt(this.width(), 10),
      y: parseInt(this.height(), 10)
    };
  };

  $.fn.outerDimensions = function(margins) {
    if (margins == null) {
      margins = true;
    }
    return {
      x: this.outerWidth(margins),
      y: this.outerHeight(margins)
    };
  };

  $.fn.showFast = function(display) {
    if (display == null) {
      display = "block";
    }
    this[0].style.display = display;
    return this;
  };

  $.fn.hideFast = function() {
    this[0].style.display = "none";
    return this;
  };

  $.fn.inDom = function() {
    return $.contains(document.documentElement, this[0]);
  };

  oldWrapAll = $.fn.wrapAll;

  $.fn.wrapAll = function(wrapper) {
    if (this.inDom()) {
      return oldWrapAll.call(this, wrapper);
    } else {
      if (!(wrapper instanceof $)) {
        wrapper = $(wrapper);
      }
      wrapper.append(this);
      return this;
    }
  };

  $.fn.appendLog = function() {
    var args, o, trackingList;
    args = 2 <= arguments.length ? slice.call(arguments, 0, o = arguments.length - 1) : (o = 0, []), trackingList = arguments[o++];
    this.append.apply(this, args);
    trackingList = trackingList.push.apply(trackingList, args);
    return this;
  };

  $.Color.fn.distanceTo = function(color, distFunc) {
    if (distFunc == null) {
      distFunc = function(c1, c2) {
        return Math.abs(c1.red() - c2.red()) + Math.abs(c1.green() - c2.green()) + Math.abs(c1.blue() - c2.blue());
      };
    }
    return distFunc(this, color);
  };

  $.Color.fn.isSimilarTo = function(color) {
    return this.distanceTo(color) / 255 < (1 - 1 / 1.61803398875);
  };

  $.Color.fn.toRgbaString = function() {
    return "rgba(" + this._rgba.join(",") + ")";
  };

  d3.transition.prototype.done = function(callback) {
    var endAll;
    endAll = function(transition) {
      var n;
      if (transition.size() === 0) {
        callback();
      }
      n = 0;
      transition.each(function() {
        ++n;
        return true;
      }).each("end", function() {
        if (!--n) {
          callback.apply(this, arguments);
        }
        return true;
      });
      return this;
    };
    return this.call(endAll, callback);
  };

  App.Tree = (function() {
    var CLASS;

    CLASS = Tree;


    /**
    * @method new
    * @static
    * @param node {Object}
    * @param options {Object}
    * Optional. Any given key will override the default. Here are the keys:
    * adjustLevels: Boolean value that indicates whether the tree is supposed to do its aftermath. Only set this to false if you're doing the aftermath later!!
    * afterInstantiate: Function to modify the node and/or the instance. Parameters are (1st) the node object and (2nd) the instance.
    * getChildren: Function that specifies how to retrieve the children from the node object.
    * getParent: Function that specifies how to retrieve the parent from the node object. getChildren is checked 1st so it doesn't make sense to pass getChildren AND getParent!
    * instantiate: Function that specifies how to create an instance from the node object. Parameter is the node object.
    *
     */

    Tree["new"] = function(node, options) {
      if (isFunction(node) && node instanceof this) {
        return new CLASS(node);
      }
      if (node.children != null) {
        return CLASS["new"].byChildRef(node);
      }
      if (node.parent != null) {
        return CLASS["new"].byParentRef(node);
      }
      if (options != null) {
        if (options.getChildren != null) {
          return CLASS["new"].byChildRef(node, options);
        }
        if (options.getParent != null) {
          return CLASS["new"].byParentRef(node, options);
        }
      }
      if (DEBUG) {
        console.warn("No recusrive structure found! Use correct options.");
      }
      return null;
    };


    /**
    * @method new.byChildRef
    * @static
    * @param node {Object}
    * @param options {Object}
    * Optional. Any given key will override the default. Here are the keys:
    * adjustLevels: Boolean value that indicates whether the tree is supposed to do its aftermath. Only set this to false if you're doing the aftermath later!!
    * afterInstantiate: Function to modify the node and/or the instance. Parameters are (1st) the node object and (2nd) the instance.
    * getChildren: Function that specifies how to retrieve the children from the node object.
    * instantiate: Function that specifies how to create an instance from the node object. Parameter is the node object.
    *
     */

    Tree["new"].byChildRef = function(node, options) {
      var adjustLevels, child, childInstance, defaultOptions, len2, o, ref, tree;
      defaultOptions = {
        getChildren: function(nodeData) {
          return nodeData.children;
        },
        instantiate: function(nodeData) {
          return new CLASS(nodeData);
        },
        afterInstantiate: function(nodeData, node) {
          return false;
        },
        adjustLevels: true
      };
      options = $.extend(defaultOptions, options);
      adjustLevels = options.adjustLevels;
      options.adjustLevels = false;
      tree = options.instantiate(node);
      options.afterInstantiate(node, tree);
      ref = options.getChildren(node) || [];
      for (o = 0, len2 = ref.length; o < len2; o++) {
        child = ref[o];
        childInstance = CLASS["new"].byChildRef(child, options);
        tree.addChild(childInstance, null, false);
      }
      if (adjustLevels) {
        tree.adjustLevels(0);
      }
      return tree;
    };


    /**
    * @method new.byParentRef
    * @static
    * @param node {Object}
    * @param options {Object}
    * Optional. Any given key will override the default. Here are the keys:
    * adjustLevels: Boolean value that indicates whether the tree is supposed to do its aftermath. Only set this to false if you're doing the aftermath later!!
    * afterInstantiate: Function to modify the node and/or the instance. Parameters are (1st) the node object and (2nd) the instance.
    * getParent: Function that specifies how to retrieve the parent from the node object.
    * instantiate: Function that specifies how to create an instance from the node object. Parameter is the node object.
    *
     */

    Tree["new"].byParentRef = function(node, getParent) {
      var tree;
      return tree = new CLASS();
    };

    Tree.fromRecursive = Tree["new"];

    function Tree(node) {
      var forbiddenKeys, k, self, v;
      self = this;
      this.children = [];
      this.parent = null;
      this.descendants = [];
      this.orderMode = "postorder";
      if (node == null) {
        this.data = {};
      } else {
        this.data = node.data || node;
        forbiddenKeys = Object.keys(this.constructor.prototype).concat(["children", "parent", "descendants", "data", "orderMode", "getClass", "getClassName", "constructor"]);
        for (k in node) {
          v = node[k];
          if (indexOf.call(forbiddenKeys, k) < 0) {
            if (!(v instanceof Function)) {
              (function(k, v) {
                return Object.defineProperty(self, k, {
                  get: function() {
                    return self.data[k];
                  },
                  set: function(val) {
                    self.data[k] = val;
                    return self;
                  }
                });
              })(k, v);
            } else {
              (function(k, v) {
                return self[k] = function() {
                  return v.call.apply(v, [node].concat(slice.call(arguments)));
                };
              })(k, v);
            }
          }
        }
      }
    }

    Object.defineProperties(Tree.prototype, {
      depth: {
        get: function() {
          return this.getDepth();
        },
        set: function() {
          return this;
        }
      },
      size: {
        get: function() {
          return this.getSize();
        },
        set: function() {
          return this;
        }
      },
      level: {
        get: function() {
          return this.getLevel();
        },
        set: function() {
          return this;
        }
      },
      root: {
        get: function() {
          return this.getRoot();
        },
        set: function() {
          return this;
        }
      }
    });

    Tree.prototype._cacheDescendants = function() {
      var child, len2, o, ref, res;
      res = [];
      ref = this.children;
      for (o = 0, len2 = ref.length; o < len2; o++) {
        child = ref[o];
        child._cacheDescendants();
        res = res.concat(child.descendants);
      }
      this.descendants = this.children.concat(res);
      return this;
    };

    Tree.prototype.equals = function(tree, compareLeaves) {
      var len2, len3, match, myChild, o, otherChild, otherChildren, p, ref;
      if (this.children.length > 0) {
        if (this.children.length !== tree.children.length || this.descendants.length !== tree.descendants.length) {
          return false;
        }
        otherChildren = tree.children.clone();
        ref = this.children;
        for (o = 0, len2 = ref.length; o < len2; o++) {
          myChild = ref[o];
          match = false;
          for (idx = p = 0, len3 = otherChildren.length; p < len3; idx = ++p) {
            otherChild = otherChildren[idx];
            if (!(myChild.equals(otherChild))) {
              continue;
            }
            match = true;
            break;
          }
          if (!match) {
            return false;
          }
          otherChildren.splice(idx, 1);
        }
        return true;
      }
      if (compareLeaves instanceof Function) {
        return compareLeaves(this, tree);
      }
      return true;
    };

    Tree.prototype.hasNode = function(node) {
      return this === node || indexOf.call(this.descendants, node) >= 0;
    };


    /**
    * Find (first occurence of) a node
    * @method findNode
    * @param equalsFunction {Function}
    *
     */

    Tree.prototype.findNode = function(filter) {
      var ref;
      return ((ref = this.findNodes(filter)) != null ? ref.first : void 0) || null;
    };

    Tree.prototype.findDescendant = function() {
      return this.findNode.apply(this, arguments);
    };


    /**
    * Find all occurences of a node.
    * @method findNodes
    * @param equalsFunction {App.Tree}
    *
     */

    Tree.prototype.findNodes = function(param) {
      var len2, node, o, ref, res;
      res = [];
      if (param instanceof Function) {
        ref = this.descendants;
        for (o = 0, len2 = ref.length; o < len2; o++) {
          node = ref[o];
          if (param(node)) {
            res.push(node);
          }
        }
      }
      return res;
    };

    Tree.prototype.findDescendants = function() {
      return this.findNodes.apply(this, arguments);
    };

    Tree.prototype.getDepth = function() {
      var maxLevel;
      if (this.children.length > 0) {
        maxLevel = this.descendants.getMax(function(node) {
          return node.level;
        });
        return maxLevel.first.level - this.level;
      }
      return 0;
    };


    /**
    * Get number of nodes in (sub)tree
    *
     */

    Tree.prototype.getSize = function() {
      return this.descendants.length + 1;
    };

    Tree.prototype.getLevel = function() {
      return this._level;
    };

    Tree.prototype.getRoot = function() {
      var root;
      if ((root = this.parent) == null) {
        return this;
      }
      while (root.parent != null) {
        root = root.parent;
      }
      return root;
    };

    Tree.prototype.getLeaves = function() {
      var child, leaves, len2, o, ref;
      leaves = [];
      ref = this.children;
      for (o = 0, len2 = ref.length; o < len2; o++) {
        child = ref[o];
        if (child.children.length > 0) {
          leaves.merge(child.getLeaves());
        } else {
          leaves.push(child);
        }
      }
      return leaves;
    };

    Tree.prototype.isLeaf = function() {
      return this.children.length === 0;
    };


    /**
    * Serialize the tree to a plain object.
    *
     */

    Tree.prototype.serialize = function(format, doneNodes) {
      var base, base1, child, len2, o, ref, serializedChildren;
      if (doneNodes == null) {
        doneNodes = [];
      }
      serializedChildren = [];
      ref = this.children;
      for (o = 0, len2 = ref.length; o < len2; o++) {
        child = ref[o];
        if (!(indexOf.call(doneNodes, child) < 0)) {
          continue;
        }
        doneNodes.push(child);
        serializedChildren.push(child.serialize(format, doneNodes));
      }
      if (format == null) {
        return {
          children: serializedChildren,
          data: (typeof (base = this.data).serialize === "function" ? base.serialize() : void 0) || JSON.parse(JSON.stringify(this.data))
        };
      }
      return format(this, serializedChildren, (typeof (base1 = this.data).serialize === "function" ? base1.serialize() : void 0) || JSON.parse(JSON.stringify(this.data)));
    };

    Tree.prototype.deserialize = function(data) {
      var len2, o, tree;
      tree = this.constructor["new"](data);
      this.children = tree.children;
      for (val = o = 0, len2 = data.length; o < len2; val = ++o) {
        key = data[val];
        if (key !== "children") {
          this[key] = val;
        }
      }
      return this;
    };

    Tree.prototype.toObject = function() {
      return this.serialize();
    };

    Tree.prototype.pathToRoot = function() {
      var parent, res;
      res = [this];
      parent = this.parent;
      while (parent != null) {
        res.push(parent);
        parent = parent.parent;
      }
      res.reverse();
      return res;
    };

    Tree.prototype.getSiblings = function() {
      var ref;
      return ((ref = this.parent) != null ? ref.children.except(this) : void 0) || [];
    };

    Tree.prototype.getLevelSiblings = function() {
      var ref, self, siblings;
      self = this;
      siblings = (ref = this.getRoot()) != null ? ref.findNodes(function(node) {
        return node.level === self.level && node !== self;
      }) : void 0;
      return siblings || [];
    };

    Tree.prototype.getParent = function() {
      return this.parent;
    };

    Tree.prototype.getChildren = function() {
      return this.children;
    };

    Tree.prototype.addChild = function(node, index, adjustLevels) {
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      if (!node.instanceOf(App.Tree)) {
        node = new CLASS(node);
      }
      if ((node.parent != null) && node.parent !== this) {
        node.moveTo(this, index);
        return this;
      }
      if (index == null) {
        this.children.push(node);
      } else {
        this.children.insert(index, node);
      }
      node.parent = this;
      if (adjustLevels) {
        node.adjustLevels(this.level);
      }
      return this;
    };

    Tree.prototype.appendChild = function() {
      return this.addChild.apply(this, arguments);
    };

    Tree.prototype.addChildren = function(nodes, index, adjustLevels) {
      var node, o;
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      for (o = nodes.length - 1; o >= 0; o += -1) {
        node = nodes[o];
        if (node != null) {
          this.addChild(node, index, false);
        }
      }
      if (adjustLevels) {
        this.adjustLevels(this.level);
      }
      return this;
    };

    Tree.prototype.appendChildren = function() {
      return this.addChildren.apply(this, arguments);
    };

    Tree.prototype.setChildren = function(nodes, clone, adjustLevels) {
      var len2, node, o;
      if (clone == null) {
        clone = false;
      }
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      this.children = [];
      if (clone) {
        nodes = (function() {
          var len2, o, results;
          results = [];
          for (o = 0, len2 = nodes.length; o < len2; o++) {
            node = nodes[o];
            if (node != null) {
              results.push(node.clone());
            }
          }
          return results;
        })();
      }
      for (o = 0, len2 = nodes.length; o < len2; o++) {
        node = nodes[o];
        this.addChild(node, false);
      }
      if (adjustLevels) {
        this.adjustLevels(this.level);
      }
      return this;
    };

    Tree.prototype.moveTo = function(targetNode, index, adjustLevels) {
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      this.remove(false);
      targetNode.addChild(this, index, adjustLevels);
      return this;
    };

    Tree.prototype.remove = function(adjustLevels) {
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      if (this.parent != null) {
        this.parent.children = this.parent.children.except(this);
        this.parent.descendants = this.parent.descendants.except(this.descendants.and(this));
        this.parent = null;
        if (adjustLevels) {
          this.adjustLevels();
        }
      }
      return this;
    };

    Tree.prototype.removeChild = function(node) {
      if (indexOf.call(this.children, node) >= 0) {
        node.remove();
      }
      return this;
    };

    Tree.prototype.removeChildAt = function(idx) {
      return removeChild(this.children[idx]);
    };

    Tree.prototype.appendTo = function(node) {
      return node.addChild(this);
    };

    Tree.prototype.adjustLevels = function(startLevel) {
      if (startLevel == null) {
        startLevel = 0;
      }
      this._cacheDescendants().each(function(n, l, i) {
        n._level = startLevel + l;
        return true;
      });
      return this;
    };


    /**
    * @method traverse
    * @param callback {Function}
    * Gets the current node, the current level relative to the root of the current traversal, and iteration index as parameters.
    * @param orderMode {String}
    * Optional. Default is "postorder". Possible are "postorder", "preorder", "inorder", "levelorder".
    * @param searchMode {String}
    * Optional. Default is "depthFirst". Posible are "depthFirst", "breadthFirst".
    *
     */

    Tree.prototype.traverse = function(callback, orderMode, inorderIndex) {
      if (orderMode == null) {
        orderMode = this.orderMode || "postorder";
      }
      if (inorderIndex == null) {
        inorderIndex = null;
      }
      return this[orderMode](callback, null, inorderIndex);
    };

    Tree.prototype.each = function() {
      return this.traverse.apply(this, arguments);
    };

    Tree.prototype.postorder = function(callback, level, info) {
      var child, len2, o, ref;
      if (level == null) {
        level = 0;
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this
        };
      }
      ref = this.children;
      for (o = 0, len2 = ref.length; o < len2; o++) {
        child = ref[o];
        child.postorder(callback, level + 1, info);
        info.idx++;
      }
      if (callback.call(info.ctx, this, level, info.idx) === false) {
        return this;
      }
      return this;
    };

    Tree.prototype.preorder = function(callback, level, info) {
      var child, len2, o, ref;
      if (level == null) {
        level = 0;
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this
        };
      }
      if (callback.call(info.ctx, this, level, info.idx) === false) {
        return this;
      }
      ref = this.children;
      for (o = 0, len2 = ref.length; o < len2; o++) {
        child = ref[o];
        child.preorder(callback, level + 1, info);
        info.idx++;
      }
      return this;
    };

    Tree.prototype.inorder = function(callback, level, index, info) {
      var i, o, p, ref, ref1, ref2;
      if (index == null) {
        index = Math.floor(this.children.length / 2);
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this
        };
      }
      for (i = o = 0, ref = index; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
        this.children[i].inorder(callback, level + 1, index, info);
        info.idx++;
      }
      if (callback.call(info.ctx, this, level, info.idx) === false) {
        return this;
      }
      for (i = p = ref1 = index, ref2 = this.children.lenth; ref1 <= ref2 ? p < ref2 : p > ref2; i = ref1 <= ref2 ? ++p : --p) {
        this.children[i].inorder(callback, level + 1, index, info);
        info.idx++;
      }
      return this;
    };

    Tree.prototype.levelorder = function(callback, level, info) {
      var currentLevel, el, list, prevLevel, startLevel;
      if (level == null) {
        level = 0;
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this,
          levelIdx: 0
        };
      }
      list = [this];
      startLevel = this.level;
      prevLevel = 0;
      while (list.length > 0) {
        el = list.shift();
        currentLevel = el.level - startLevel;
        if (currentLevel > prevLevel) {
          info.levelIdx = 0;
        }
        if (callback.call(info.ctx, el, currentLevel, info) === false) {
          return this;
        }
        prevLevel = currentLevel;
        info.idx++;
        info.levelIdx++;
        list = list.concat(el.children);
      }
      return this;
    };

    return Tree;

  })();

  App.Leaf = (function(superClass) {
    var CLASS;

    extend(Leaf, superClass);

    CLASS = Leaf;

    Leaf["new"] = function(node) {
      return new this(node);
    };

    function Leaf(node) {
      Leaf.__super__.constructor.call(this, node);
      delete this.children;
      Object.defineProperty(this, "children", {
        get: function() {
          return [];
        },
        set: function() {
          throw new Error("App.Leaf::children=: Cannot set children of a leaf!");
        }
      });
    }

    Leaf.prototype._cacheDescendants = function() {
      return this;
    };

    Leaf.prototype.findNodes = function(param) {
      return null;
    };

    Leaf.prototype.getDepth = function() {
      return 0;
    };

    Leaf.prototype.getSize = function() {
      return 0;
    };

    Leaf.prototype.getLevel = function() {
      return this._level;
    };

    Leaf.prototype.getLeaves = function() {
      return [];
    };

    Leaf.prototype.isLeaf = function() {
      return true;
    };

    Leaf.prototype.serialize = function(format) {
      var base, base1;
      if (format == null) {
        return {
          children: [],
          data: (typeof (base = this.data).serialize === "function" ? base.serialize() : void 0) || JSON.parse(JSON.stringify(this.data))
        };
      }
      return format(this, [], (typeof (base1 = this.data).serialize === "function" ? base1.serialize() : void 0) || JSON.parse(JSON.stringify(this.data)));
    };

    Leaf.prototype.deserialize = function(data) {
      this.data = data;
      return this;
    };

    Leaf.prototype.getChildren = function() {
      return [];
    };

    Leaf.prototype.addChild = function() {
      throw new Error("App.Leaf::addChild: Cannot add a child to a leaf!");
    };

    Leaf.prototype.addChildren = function() {
      throw new Error("App.Leaf::addChildren: Cannot add children to a leaf!");
    };

    Leaf.prototype.setChildren = function() {
      throw new Error("App.Leaf::setChildren: Cannot set children of a leaf!");
    };

    Leaf.prototype.removeChild = function() {
      throw new Error("App.Leaf::removeChild: Cannot remove children of a leaf!");
    };

    Leaf.prototype.removeChildAt = function(idx) {
      throw new Error("App.Leaf::removeChildAt: Cannot remove children of a leaf!");
    };

    Leaf.prototype.adjustLevels = function() {
      return this;
    };

    return Leaf;

  })(App.Tree);

}).call(this);
