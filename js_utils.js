// Generated by CoffeeScript 1.10.0
(function() {
  var arrEquals, funcForArgs, method, methodName, parent, preferJSUtils, prototyping, set, setName, wrapAllOrig,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  window.DEBUG = true;

  window.JSUtils = {};


  /**
   * A class that executes asynchronous functions in an order.
   *
   * @example
   * `var seq = new Sequence([
   *     {
   *      func: () ->
   *          return true
   *      scope: someObject
   *      params: [1,2,3]
   *     }
   *     {
   *      func: () ->
   *          return new JSUtils.Sequence(...)
   *      scope: someObject
   *      params: (prevRes, presFunc, prevParams, idx) ->
   *          return [...]
   *     }
   *     [
   *      () -> return true,
   *      someObject,
   *      [1,2,3]
   *     ]
   * ])`
   *
   * Each asynchronous function MUST return an object that implements a `done()` method!
   *
   * This `done()` method takes 1 callback function as parameter (not like jQuery which can take multiple and arrays)! If parameters are to be passed to the callback, take care of it yourself (closuring?!).
   * When using `done()` callbacks in that asynchronous function those callbacks MUST be synchronous to make sure the order remains correct.
   *
   * @class Sequence
   * @extends Object
   * @constructor
   * @param data {Array}
   * Each element of that array is either an object like `{func: ..., scope: ..., params: ...}` and an array with the same values in that order.
   * For each element applies:
   * 'func' (or the 1st array element) is the function being executed.
   * 'scope' (or the 2nd element) is an object that serves as `this` in 'func'.
   * 'params' (or the 3rd element) is either
   * an array of parameters being passed to 'func'
   * or a function that creates such an array. In that case that function must have the form:
   * `(resultOfPreviouslyExecutedFunction, parametersOfPreviousCallback, previouslyExecutedFunction, scopeOfPreviouslyExecutedFunction, parametersOfPreviouslyExecutedFunction, indexInExecutionList) ->
   *     params = [...do stuff...]
   *     return params`
   * See the example or the static `test()` method for details.
   * @param start {Boolean}
   * Optional. Default is `true`. If it's `!== true` the Sequence will not start automatically. The `start()` method can be used to start it whenever.
  *
   */

  JSUtils.Sequence = (function() {
    Sequence.PARAM_MODES = {
      CONTEXT: "CONTEXT",
      IMPLICIT: "IMPLICIT",
      EXPLICIT: "EXPLICIT"
    };


    /**
    * This method does the same as window.setTimeout() but makes it useable by JSUtils.Sequence. It also takes an additional (optional) scope parameter.
    * Basically window.setTimeout() is used in order to delay a whole Sequence.
    *
    * The mechanism is lik so:
    * An empty Sequence is created and returned (after it returns the `done()` callback is added by the Sequence itself).
    * The empty Sequence is delayed by 'delay' (with the help of window.setTimeout()) and when before it starts the passed function 'func', 'scope', and all 'params' passed to the Sequence.
    * @static
    * @method setTimeout
    * @param {Function|String} func
    * This parameter is either a function or a code string.
    * @param {Integer} delay
    * @param {Function} scope
    * @param {mixed} param1
    * @param {mixed} param2
    * @param ...
    *
     */

    function Sequence(data, start, stopOnError) {
      if (data == null) {
        data = [];
      }
      if (start == null) {
        start = true;
      }
      if (stopOnError == null) {
        stopOnError = true;
      }
      this.data = data;
      this.idx = 0;
      this.stopOnError = stopOnError;
      this._doneCallbacks = [];
      this._startCallback = null;
      this._endCallback = null;
      this._isDone = false;
      this._isStopped = false;
      this._parameterMode = this.constructor.PARAM_MODES.EXPLICIT;
      if (start === true) {
        this.start();
      }
    }


    /**
    * This method starts the Sequence in case it has been created with `false` as start parameter.
    * @method start
    * @param newData {Array}
    * Optional. If an array is given it will replace the possibly previously set data.
    * @return This istance. {Sequence}
    * @chainable
    *
     */

    Sequence.prototype.start = function(newData) {
      if (newData instanceof Array) {
        this.data = newData;
      }
      if (typeof this._startCallback === "function") {
        this._startCallback();
      }
      this._invokeNextFunction();
      return this;
    };

    Sequence.prototype._createParamListFromContext = function(func, context) {
      var argName, len1, m, paramList, temp;
      if (!(context instanceof Array)) {
        paramList = func.toString().split(/[()]/g).second.split(/\s*,\s*/g);
        temp = [];
        for (m = 0, len1 = paramList.length; m < len1; m++) {
          argName = paramList[m];
          temp.push(context[argName]);
        }
        return temp;
      }
      return context.slice(0);
    };


    /**
    * This method invokes the next function in the list.
    * @protected
    * @method _invokeNextFunction
    * @param previousReult {mixed}
    * The result the previously executed function returned or `null`.
    * @param args... {mixed}
    * These are the arguments passed to the callback itself.
    * @return This istance. {Sequence}
    * @chainable
    *
     */

    Sequence.prototype._invokeNextFunction = function() {
      var CLASS, args, d, data, error, error1, func, newParams, params, ref, ref1, res, scope, self;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this._isStopped) {
        return this;
      }
      data = this.data[this.idx];
      if (data != null) {
        if (data instanceof Array) {
          func = data[0];
          scope = data[1];
          params = data[2];
        } else {
          func = data.func;
          scope = data.scope;
          params = data.params;
        }
        if (func != null) {
          CLASS = this.constructor;
          self = this;
          if (params instanceof Array && params.length > 0) {
            this._parameterMode = CLASS.PARAM_MODES.EXPLICIT;
          }
          if (this._parameterMode === CLASS.PARAM_MODES.CONTEXT) {
            newParams = this._createParamListFromContext(func, args[0].context);
          } else if (this._parameterMode === CLASS.PARAM_MODES.EXPLICIT) {
            newParams = params;
          } else if (this._parameterMode === CLASS.PARAM_MODES.IMPLICIT) {
            newParams = args;
          }
          if (params instanceof Function) {
            d = this.data[this.idx - 1];
            newParams = params(args, {
              func: (d != null ? d.func : void 0) || (d != null ? d[0] : void 0),
              scope: (d != null ? d.scope : void 0) || (d != null ? d[1] : void 0) || null,
              params: (d != null ? (ref = d.params) != null ? ref.slice(0) : void 0 : void 0) || (d != null ? (ref1 = d[2]) != null ? ref1.slice(0) : void 0 : void 0) || []
            }, this.idx);
          }
          try {
            res = func.apply(scope || window, newParams);
          } catch (error1) {
            error = error1;
            res = null;
            console.error("=================================================================");
            console.error("JSUtils.Sequence::_invokeNextFunction: Given function (at index " + this.idx + ") threw an Error!");
            console.warn("Here is the data:", data);
            console.warn("Here is the error:", error);
            console.error("=================================================================");
            if (this.stopOnError) {
              this.interrupt();
            }
          }
          if (((res != null ? res.done : void 0) != null) && ((res != null ? res.context : void 0) != null)) {
            res.done.done(function() {
              self.idx++;
              self._parameterMode = CLASS.PARAM_MODES.CONTEXT;
              return self._invokeNextFunction(res);
            });
          } else if ((res != null ? res.done : void 0) != null) {
            res.done(function() {
              self.idx++;
              self._parameterMode = CLASS.PARAM_MODES.IMPLICIT;
              return self._invokeNextFunction.apply(self, arguments);
            });
          } else if (res != null ? res.context : void 0) {
            this.idx++;
            this._parameterMode = CLASS.PARAM_MODES.CONTEXT;
            this._invokeNextFunction(res);
          } else {
            this.idx++;
            this._parameterMode = CLASS.PARAM_MODES.IMPLICIT;
            this._invokeNextFunction(res);
          }
        }
      } else {
        this.lastResult = args[0];
        if (this._parameterMode === this.constructor.PARAM_MODES.CONTEXT) {
          this.lastResult = this.lastResult.context;
        }
        if (typeof this._endCallback === "function") {
          this._endCallback();
        }
        this._execDoneCallbacks();
      }
      return this;
    };


    /**
    * This method is called when the Sequence has executed all of its functions. It will then start executing all callbacks that previously have been added via `done()` (in the order they were added). No callback receives any parameters.
    * @protected
    * @method _execDoneCallbacks
    * @return This istance. {Sequence}
    * @chainable
    *
     */

    Sequence.prototype._execDoneCallbacks = function() {
      var cb, len1, m, ref;
      this._isDone = true;
      ref = this._doneCallbacks;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        cb = ref[m];
        cb();
      }
      return this;
    };

    Sequence.prototype.stop = function(execCallbacks) {
      if (execCallbacks == null) {
        execCallbacks = true;
      }
      this._isStopped = true;
      if (execCallbacks) {
        if (typeof this._endCallback === "function") {
          this._endCallback();
        }
        this._execDoneCallbacks();
      }
      return this;
    };

    Sequence.prototype.interrupt = function() {
      return this.stop(false);
    };

    Sequence.prototype.resume = function() {
      this._isStopped = false;
      this._invokeNextFunction();
      return this;
    };


    /**
    * Callback that gets called before the queue is being processed.
    * @method onStart
    *
     */

    Sequence.prototype.onStart = function() {
      var args, callback, context;
      callback = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof callback === "function") {
        this._startCallback = function() {
          return callback.apply(context, args);
        };
      }
      return this;
    };


    /**
    * Callback that gets called after the queue is processed but before the done callbacks are triggered.
    * @method onEnd
    *
     */

    Sequence.prototype.onEnd = function() {
      var args, callback, context;
      callback = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof callback === "function") {
        this._endCallback = function() {
          return callback.apply(context, args);
        };
      }
      return this;
    };


    /**
    * This method adds a callback that will be executed after all functions have returned.
    * @method done
    * @param callback {Function}
    * A function (without parameters).
    * @param context {Object}
    * @param args... {Function}
    * Arguments to be passed to the callback function.
    * @return This istance. {Sequence}
    * @chainable
    *
     */

    Sequence.prototype.done = function() {
      var args, callback, context, self;
      callback = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof callback === "function") {
        self = this;
        if (!this._isDone) {
          this._doneCallbacks.push(function() {
            return callback.apply(context, args.concat([self.lastResult]));
          });
        } else {
          callback.apply(context, args.concat([self.lastResult]));
        }
      }
      return this;
    };

    Sequence.prototype.then = Sequence.prototype.done;


    /**
    * This method returns the progress of the Sequence in [0,1].
    * @method getProgress
    * @return progress {Number}
    *
     */

    Sequence.prototype.progress = function() {
      return this.idx / this.data.length;
    };


    /**
    * @method while
    * @return {Sequence}
    * @chainable
    *
     */

    Sequence.prototype["while"] = function(startFunc, endFunc, context, args) {
      this.onStart(startFunc, context, args);
      this.onEnd(endFunc, context, args);
      return this;
    };

    return Sequence;

  })();

  if (DEBUG) {
    JSUtils.Sequence.test = function() {
      var sequence;
      return sequence = new JSUtils.Sequence([
        {
          func: function(id, idx) {
            console.log("func1! idx = " + idx + (idx != null ? " (called again...so actually func2 ^^)" : ""));
            return this.get("http://localhost:3000/api/report/" + id);
          },
          scope: $,
          params: [12]
        }, {
          func: function(response) {
            console.log("jquery get callback:", response);
            return response;
          }
        }, {
          func: function(response) {
            console.log("next seq function with prev result:", response);
            return true;
          }
        }
      ], false)["while"](loadingIndicator.start, loadingIndicator.stop, loadingIndicator).start();
    };
  }


  /**
  * A class that starts executing asynchronous functions and waits for them to finish.
  *
  * @example
  * `var barrier = new Barrier([
  *     {
  *      func: () ->
  *          return true
  *      scope: someObject
  *      params: [1,2,3]
  *     }
  *     {
  *      func: () ->
  *          return new JSUtils.Sequence(...)
  *      scope: someObject
  *     [
  *      () -> return true,
  *      someObject,
  *      [1,2,3]
  *     ]
  * ])`
  *
  * Each asynchronous function MUST return an object that implements a `done()` method!
  *
  * This `done()` method takes 1 callback function as parameter (not like jQuery which can take multiple and arrays)! If parameters are to be passed to the callback, take care of it yourself (closuring?!).
  * When using `done()` callbacks in that asynchronous function those callbacks MUST be synchronous to make sure the order remains correct.
  *
  * @class Barrier
  * @extends Object
  * @constructor
  * @param data {Array}
  * Each element of that array is either an object like `{func: ..., scope: ..., params: ...}` and an array with the same values in that order.
  * For each element applies:
  * 'func' (or the 1st array element) is the function being executed.
  * 'scope' (or the 2nd element) is an object that serves as `this` in 'func'.
  * 'params' (or the 3rd element) is an array of parameters being passed to 'func'
  * or a function that creates such an array. In that case that function must have the form:
  * @param start {Boolean}
  * Optional. Default is `true`. If it's `!== true` the Sequence will not start automatically. The `start()` method can be used to start it whenever.
  *
   */

  JSUtils.Barrier = (function() {
    Barrier.forArray = function(array, callback, start) {
      var data, elem, len1, m;
      if (array == null) {
        array = [];
      }
      if (start == null) {
        start = true;
      }
      data = [];
      for (m = 0, len1 = array.length; m < len1; m++) {
        elem = array[m];
        data.push({
          func: (function(elem) {
            return function() {
              return callback(elem);
            };
          })(elem)
        });
      }
      return new JSUtils.Barrier(data, start);
    };

    function Barrier(data, start) {
      if (data == null) {
        data = [];
      }
      if (start == null) {
        start = true;
      }
      this.data = data;
      this.remainingThreads = data.length;
      this.funcResults = [];
      this._doneCallbacks = [];
      this._startCallback = null;
      this._endCallback = null;
      this._endAllCallback = null;
      this._isDone = false;
      this._isStopped = false;
      this._sequences = [];
      if (start === true) {
        this.start();
      }
    }


    /**
    * This method starts the Barrier in case it has been created with `false` as start parameter.
    * @method start
    * @param newData {Array}
    * Optional. If an array is given it will replace the possibly previously set data.
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype.start = function(newData) {
      var d, idx, len1, m, ref;
      if (newData instanceof Array) {
        this.data = newData;
        this.remainingThreads = newData.length;
      }
      if (typeof this._startCallback === "function") {
        this._startCallback();
      }
      if (this.remainingThreads > 0) {
        ref = this.data;
        for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
          d = ref[idx];
          if (d != null) {
            this._invokeNextFunction(d, idx);
          }
        }
      } else {
        this._funcDone();
      }
      return this;
    };


    /**
    * This method invokes the next function in the list.
    * @protected
    * @method _invokeNextFunction
    * @param data {Object|Array}
    * Function data (same structure as in JSUtils.Sequence)
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype._invokeNextFunction = function(data, idx) {
      var func, params, scope;
      if (this._isStopped) {
        return this;
      }
      func = data.func || data[0];
      scope = data.scope || data[1];
      params = data.params || data[2];
      this._sequences.push(new JSUtils.Sequence([
        {
          func: function() {
            var error, error1;
            try {
              return func.apply(scope, params);
            } catch (error1) {
              error = error1;
              return error;
            }
          }
        }, {
          func: function(prevResOrResponse) {
            this.funcResults[idx] = prevResOrResponse;
            this._funcDone();
            return this;
          },
          scope: this
        }
      ]));
      return this;
    };

    Barrier.prototype._funcDone = function() {
      console.log("barrier: decrementing remainingThreads from " + this.remainingThreads + " to " + (this.remainingThreads - 1));
      if (--this.remainingThreads <= 0) {
        this._isDone = true;
        if (typeof this._endCallback === "function") {
          this._endCallback();
        }
        this._execDoneCallbacks();
        if (typeof this._endAllCallback === "function") {
          this._endAllCallback();
        }
      }
      return this;
    };


    /**
    * This method adds a callback that will be executed after all functions have returned.
    * @method done
    * @param callback {Function}
    * A function (without parameters).
    * @param context {Object}
    * @param args... {Function}
    * Arguments to be passed to the callback function.
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype.done = function() {
      var args, callback, context, self;
      callback = arguments[0], context = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (typeof callback === "function") {
        self = this;
        if (!this._isDone) {
          this._doneCallbacks.push(function() {
            return callback.apply(context, args.concat([self.funcResults]));
          });
        } else {
          callback.apply(context, args.concat([self.funcResults]));
        }
      }
      return this;
    };

    Barrier.prototype.then = Barrier.prototype.done;


    /**
    * This method returns the progress (how many async function have already reached the Barrier) in [0,1].
    * @method getProgress
    * @return progress {Number}
    *
     */

    Barrier.prototype.getProgress = function() {
      return 1 - this.remainingThreads / this.data.length;
    };


    /**
    * This method is called when the Sequence has executed all of its functions. It will then start executing all callbacks that previously have been added via `done()` (in the order they were added). No callback receives any parameters.
    * @protected
    * @method _execDoneCallbacks
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype._execDoneCallbacks = function() {
      var cb, len1, m, ref;
      ref = this._doneCallbacks;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        cb = ref[m];
        cb();
      }
      return this;
    };


    /**
    * This method sets the start and end callback that are executed before the Barrier starts and after it's done (but before the done callbacks are being executed).
    * @protected
    * @method while
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype["while"] = function(startCallback, endCallback, context) {
      if (context != null) {
        this._startCallback = function() {
          return context.startCallback();
        };
        this._endCallback = function() {
          return context.endCallback();
        };
      } else {
        this._startCallback = startCallback;
        this._endCallback = endCallback;
      }
      return this;
    };


    /**
    * Same as while() but the 2nd parameter is executed AFTER the done callbacks.
    * @protected
    * @method whileAll
    * @return This istance. {Barrier}
    * @chainable
    *
     */

    Barrier.prototype.whileAll = function(startCallback, endCallback, context) {
      if (context != null) {
        this._startCallback = function() {
          return context.startCallback();
        };
        this._endAllCallback = function() {
          return context.endCallback();
        };
      } else {
        this._startCallback = startCallback;
        this._endAllCallback = endCallback;
      }
      return this;
    };

    Barrier.prototype.stop = function(execCallbacks) {
      var len1, m, ref, sequence;
      if (execCallbacks == null) {
        execCallbacks = true;
      }
      this._isStopped = true;
      ref = this._sequences;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        sequence = ref[m];
        sequence.stop(execCallbacks);
      }
      if (execCallbacks) {
        if (typeof this._endCallback === "function") {
          this._endCallback();
        }
        this._execDoneCallbacks();
      }
      return this;
    };

    Barrier.prototype.interrupt = function() {
      return this.stop(false);
    };

    Barrier.prototype.resume = function() {
      this._isStopped = false;
      this._invokeNextFunction();
      return this;
    };

    return Barrier;

  })();

  JSUtils.Doneable = new JSUtils.Sequence();


  /**
   * This is an implementation of a dictionary/hash that does not convert its keys into Strings. Keys can therefore actually by anything! :)
   * @class Configurator
   * @constructor
  *
   */

  JSUtils.Hash = (function() {

    /**
     * Creates a new Hash from a given JavaScript object.
     * @static
     * @method fromObject
     * @param object {Object}
    *
     */
    var _putObject;

    Hash.fromObject = function(obj) {
      var hash, key, val;
      hash = new JSUtils.Hash();
      for (key in obj) {
        val = obj[key];
        hash.put(key, val);
      }
      return hash;
    };

    function Hash(obj, defaultVal, equality) {
      var key, val;
      if (defaultVal == null) {
        defaultVal = null;
      }
      this.keys = [];
      this.values = [];
      this.equality = equality;
      if (obj != null) {
        for (key in obj) {
          val = obj[key];
          this.put(key, val);
        }
      }
    }

    Hash.prototype.toObject = function() {
      var idx, key, len1, m, ref, res;
      res = {};
      ref = this.keys;
      for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
        key = ref[idx];
        res[key] = this.values[idx];
      }
      return res;
    };

    Hash.prototype.clone = function() {
      var res;
      res = new JSUtils.Hash();
      res.keys = this.keys.clone();
      res.values = this.values.clone();
      return res;
    };

    Hash.prototype.invert = function() {
      var res;
      res = new JSUtils.Hash();
      res.keys = this.values.clone();
      res.values = this.keys.clone();
      return res;
    };


    /**
     * Adds a new key-value pair or overwrites an existing one.
     * @private
     * @method _putObject
     * @param object {Object}
     * @return {Hash} This instance.
     * @chainable
    *
     */

    _putObject = function(obj) {
      var key, val;
      for (key in obj) {
        val = obj[key];
        this.put(key, val);
      }
      return this;
    };


    /**
     * Return the index of the given key
     * @method findKeyIdx
     * @param key {mixed}
     * @return {Hash} This instance.
     * @chainable
    *
     */

    Hash.prototype.findKeyIdx = function(key) {
      var el, idx, len1, m, ref;
      ref = this.keys;
      for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
        el = ref[idx];
        if ((typeof this.equality === "function" ? this.equality(el, key) : void 0) || el === key) {
          return idx;
        }
      }
      return -1;
    };


    /**
     * Adds a new key-value pair or overwrites an existing one.
     * @method put
     * @param key {mixed}
     * @param val {mixed}
     * @return {Hash} This instance.
     * @chainable
    *
     */

    Hash.prototype.put = function(key, val) {
      var idx;
      if (val == null) {
        return _putObject.call(this, key);
      }
      idx = this.findKeyIdx(key);
      if (idx < 0) {
        this.keys.push(key);
        this.values.push(val);
      } else {
        this.keys[idx] = key;
        this.values[idx] = val;
      }
      return this;
    };


    /**
     * Adds a new key-value pair or overwrites an existing one.
     * @method putMultiple
     * @param pairs... {mixed}
     * @param val {mixed}
     * @return {Hash} This instance.
     * @chainable
    *
     */

    Hash.prototype.putMultiple = function() {
      var idx, key, len1, m, pairs, ref, val;
      pairs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      for (m = 0, len1 = pairs.length; m < len1; m++) {
        ref = pairs[m], key = ref[0], val = ref[1];
        if (val == null) {
          _putObject.call(this, key);
        }
        idx = this.findKeyIdx(key);
        if (idx < 0) {
          this.keys.push(key);
          this.values.push(val);
        } else {
          idx = this.keys.indexOf(key);
          if (idx < 0) {
            this.keys.push(key);
            this.values.push(val);
          } else {
            this.keys[idx] = key;
            this.values[idx] = val;
          }
        }
      }
      return this;
    };


    /**
     * Returns the value (or null) for the specified key.
     * @method get
     * @param key {mixed}
     * @param [equalityFunction] {Function}
     * This optional function can overwrite the test for equality between keys. This function expects the parameters: (the current key in the key iteration, 'key'). If this parameters is omitted '===' is used.
     * @return {mixed}
    *
     */

    Hash.prototype.get = function(key, eqFunc) {
      var i, idx, k;
      if (eqFunc == null) {
        idx = this.findKeyIdx(key);
      } else {
        idx = ((function() {
          var len1, m, ref, results;
          ref = this.keys;
          results = [];
          for (i = m = 0, len1 = ref.length; m < len1; i = ++m) {
            k = ref[i];
            if (eqFunc(k, key) === true) {
              results.push(i);
            }
          }
          return results;
        }).call(this)).first;
      }
      if (idx >= 0) {
        return this.values[idx];
      }
      return (typeof this.defaultVal === "function" ? this.defaultVal() : void 0) || this.defaultVal;
    };


    /**
     * Returns a list of all key-value pairs. Each pair is an Array with the 1st element being the key, the 2nd being the value.
     * @method getAll
     * @return {Array} Key-value pairs.
    *
     */

    Hash.prototype.getAll = function() {
      var idx, key, len1, m, ref, res;
      res = [];
      ref = this.keys;
      for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
        key = ref[idx];
        res.push([key, this.values[idx]]);
      }
      return res;
    };


    /**
     * Indicates whether the Hash has the specified key.
     * @method hasKey
     * @param key {mixed}
     * @return {Boolean}
    *
     */

    Hash.prototype.hasKey = function(key) {
      return this.findKeyIdx(key) >= 0;
    };

    Hash.prototype.has = Hash.prototype.hasKey;


    /**
     * Returns the number of entries in the Hash.
     * @method size
     * @return {Integer}
    *
     */

    Hash.prototype.size = function() {
      return this.keys.length;
    };


    /**
     * Returns all the keys of the Hash.
     * @method getKeys()
     * @return {Array}
    *
     */

    Hash.prototype.getKeys = function() {
      return this.keys;
    };


    /**
     * Returns all the values of the Hash.
     * @method getValues()
     * @return {Array}
    *
     */

    Hash.prototype.getValues = function() {
      return this.values;
    };


    /**
     * Returns a list of keys that have val (or anything equal as specified in 'eqFunc') as value.
     * @method getKeysForValue
     * @param val {mixed}
     * @param [equalityFunction] {Function}
     * This optional function can overwrite the test for equality between values. This function expects the parameters ('value' and the current value in the value iteration). If this parameters is omitted '===' is used.
     * @return {mixed}
    *
     */

    Hash.prototype.getKeysForValue = function(value, eqFunc) {
      var idx, idxs, val;
      if (eqFunc == null) {
        idxs = (function() {
          var len1, m, ref, results;
          ref = this.values;
          results = [];
          for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
            val = ref[idx];
            if (this.equality(val, value) || val === value) {
              results.push(idx);
            }
          }
          return results;
        }).call(this);
      } else {
        idxs = (function() {
          var len1, m, ref, results;
          ref = this.values;
          results = [];
          for (idx = m = 0, len1 = ref.length; m < len1; idx = ++m) {
            val = ref[idx];
            if (eqFunc(val, value) === true) {
              results.push(idx);
            }
          }
          return results;
        }).call(this);
      }
      return (function() {
        var len1, m, results;
        results = [];
        for (m = 0, len1 = idxs.length; m < len1; m++) {
          idx = idxs[m];
          results.push(this.keys[idx]);
        }
        return results;
      }).call(this);
    };

    Hash.prototype.empty = function() {
      this.keys = [];
      this.values = [];
      return this;
    };

    Hash.prototype.remove = function(key) {
      var idx;
      idx = this.keys.indexOf(key);
      if (idx >= 0) {
        this.keys.splice(idx, 1);
        this.values.splice(idx, 1);
      } else {
        console.warn("Could not remove key '" + key + "'!");
      }
      return this;
    };

    Hash.prototype.each = function(callback) {
      var i, key, len1, m, ref;
      ref = this.keys;
      for (i = m = 0, len1 = ref.length; m < len1; i = ++m) {
        key = ref[i];
        if (callback(key, this.values[i], i) === false) {
          return this;
        }
      }
      return this;
    };

    return Hash;

  })();

  arrEquals = function(arr1, arr2) {
    var i, len1, m, x;
    if (arr1.length !== arr2.length) {
      return false;
    }
    for (i = m = 0, len1 = arr1.length; m < len1; i = ++m) {
      x = arr1[i];
      if (x !== arr2[i]) {
        return false;
      }
    }
    return true;
  };

  funcForArgs = function(args, argLists, funcs) {
    var arg, argList, argListToCheck, i, lastMatchedIdx, len1, m;
    argListToCheck = (function() {
      var len1, m, results;
      results = [];
      for (m = 0, len1 = args.length; m < len1; m++) {
        arg = args[m];
        results.push(arg.constructor);
      }
      return results;
    })();
    for (i = m = 0, len1 = argLists.length; m < len1; i = ++m) {
      argList = argLists[i];
      if (arrEquals(argList, argListToCheck)) {
        return funcs[i] || funcs[lastMatchedIdx];
      }
      lastMatchedIdx = i;
    }
    return null;
  };

  JSUtils.jOverload = function() {
    var arg, argList, argLists, args, funcs, i, j, k, len, m, name, ref, type;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    argLists = [];
    funcs = [];
    i = 0;
    len = args.length;
    while (i < len) {
      j = i;
      while (!((argList = args[j]) instanceof Function) && j < len) {
        if (!(argList instanceof Array)) {
          argLists.push((function() {
            var results;
            results = [];
            for (name in argList) {
              type = argList[name];
              results.push(type);
            }
            return results;
          })());
        } else {
          argLists.push(argList);
        }
        j++;
      }
      if (j < len) {
        funcs.push(args[j]);
        for (k = m = 0, ref = j - i - 1; 0 <= ref ? m < ref : m > ref; k = 0 <= ref ? ++m : --m) {
          funcs.push(null);
        }
        i = j + 1;
      } else {
        throw new Error("No function given for argument lists: " + (JSON.stringify((function() {
          var len1, o, ref1, results;
          ref1 = args.slice(i);
          results = [];
          for (o = 0, len1 = ref1.length; o < len1; o++) {
            argList = ref1[o];
            results.push((function() {
              var len2, p, results1;
              results1 = [];
              for (p = 0, len2 = argList.length; p < len2; p++) {
                arg = argList[p];
                results1.push(arg.name);
              }
              return results1;
            })());
          }
          return results;
        })())));
      }
    }
    return function() {
      var f;
      if ((f = funcForArgs(arguments, argLists, funcs)) != null) {
        return f.apply(this, arguments);
      }
      throw new Error("Arguments do not match any known argument list!");
    };
  };

  prototyping = {};

  preferJSUtils = true;

  prototyping["Math"] = {
    isNum: function(n) {
      return (n != null) && (typeof n === "number" || n instanceof Number) && isFinite(n);
    },
    average: function() {
      var elem, elems, len1, m, sum, vals;
      vals = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      sum = 0;
      elems = 0;
      for (m = 0, len1 = vals.length; m < len1; m++) {
        elem = vals[m];
        if (!(Math.isNum(elem))) {
          continue;
        }
        sum += elem;
        elems++;
      }
      return sum / elems;
    },
    sign: function(n) {
      if (Math.isNum(n)) {
        if (n < 0) {
          return -1;
        }
        if (n > 0) {
          return 1;
        }
        return 0;
      }
      return void 0;
    },
    log10: function(x) {
      if (Math.isNum(x) && x > 0) {
        return Math.log(x) / Math.LN10;
      }
      return void 0;
    }
  };

  prototyping["Function::"] = {
    clone: function() {
        var that = this;
        var temp = function temporary() { return that.apply(this, arguments); };
        for( key in this ) {
            temp[key] = this[key];
        }
        return temp;
    }
  };

  prototyping["Object"] = {
    except: function() {
      var k, keys, obj, res, v;
      obj = arguments[0], keys = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (keys.first instanceof Array) {
        keys = keys.first;
      }
      keys = keys.concat(Object.keys(obj.__proto__));
      res = {};
      for (k in obj) {
        v = obj[k];
        if (indexOf.call(keys, k) < 0) {
          res[k] = v;
        }
      }
      res.__proto__ = obj.__proto__;
      return res;
    },
    values: function(obj) {
      var key, val;
      if (DEBUG) {
        if (!(obj instanceof Object)) {
          throw new Error("Called non-object: " + obj);
        }
      }
      return (function() {
        var results;
        results = [];
        for (key in obj) {
          val = obj[key];
          results.push(val);
        }
        return results;
      })();
    },
    swapValues: function() {
      var i, key1, key2, keys, m, obj, ref, temp;
      obj = arguments[0], keys = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (keys.length % 2 === 0) {
        for (i = m = 0, ref = keys.length; m < ref; i = m += 2) {
          key1 = keys[i];
          key2 = keys[i + 1];
          temp = obj[key1];
          obj[key1] = obj[key2];
          obj[key2] = temp;
        }
      }
      return obj;
    }
  };

  prototyping["Element::"] = {
    remove: function() {
      return this.parentNode.removeChild(this);
    }
  };

  String.prototype.replaceMultiple = function(array, mode) {
    var cbFun, i, length, m, modes, needle, o, ref, ref1, repl, temp;
    if ((array == null) || array.length < 2) {
      return this;
    }
    length = array.length;
    modes = {
      0: 0,
      tuples: 0,
      1: 1,
      diffByOne: 1,
      2: 2,
      oneByDiff: 2
    };
    mode = modes[mode];
    if (mode == null) {
      mode = 0;
    }
    temp = this;
    if (mode === 0) {
      if (length & 1) {
        return this;
      }
      for (i = m = 0, ref = length; m < ref; i = m += 2) {
        temp = temp.replace(array[i], array[i + 1]);
      }
    }
    if (mode === 1) {
      repl = array[length - 1];
      for (i = o = 0, ref1 = length - 1; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
        temp = temp.replace(array[i], repl);
      }
    }
    if (mode === 2) {
      if (length !== 2) {
        return this;
      }
      needle = array.first;
      cbFun = array.second;
      i = 0;
      while (temp.indexOf(needle) !== -1 && i < temp.length) {
        temp = temp.replace(needle, cbFun(i));
        i++;
      }
    }
    return temp;
  };

  String.prototype.firstToUpper = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
  };

  String.prototype.firstToLower = function() {
    return this.charAt(0).toLowerCase() + this.slice(1);
  };

  String.prototype.capitalize = function() {
    var len1, m, ref, res, word;
    res = "";
    ref = this.split(" ");
    for (m = 0, len1 = ref.length; m < len1; m++) {
      word = ref[m];
      res += (word.firstToUpper()) + " ";
    }
    return res.trim();
  };

  String.prototype.camelToKebab = function() {
    return this.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/\b([A-Z]+)([A-Z])([a-z])/, '$1-$2$3').toLowerCase();
  };

  String.prototype.snakeToCamel = function() {
    var char, len1, m, prevChar, res;
    res = "";
    for (m = 0, len1 = this.length; m < len1; m++) {
      char = this[m];
      if (char !== "_") {
        if (prevChar !== "_") {
          res += char;
        } else {
          res += char.toUpperCase();
        }
      }
      prevChar = char;
    }
    return res;
  };

  String.prototype.camelToSnake = function() {
    var char, len1, m, prevChar, res;
    res = "";
    prevChar = null;
    for (m = 0, len1 = this.length; m < len1; m++) {
      char = this[m];
      if (char === char.toLowerCase()) {
        res += char;
      } else {
        if (prevChar) {
          res += "_" + char.toLowerCase();
        } else {
          res += char.toLowerCase();
        }
      }
      prevChar = char;
    }
    return res;
  };

  String.prototype.lower = String.prototype.toLowerCase;

  String.prototype.upper = String.prototype.toUpperCase;

  String.prototype.isNumeric = function() {
    var parsed;
    parsed = parseFloat(this);
    return (("" + parsed) === ("" + this) || ("+" + parsed) === ("" + this)) && Math.isNum(parsed);
  };

  String.prototype.endsWith = function(end) {
    var index;
    index = this.lastIndexOf(end);
    if (index >= 0) {
      return index + end.length === this.length;
    }
    return false;
  };

  String.prototype.times = function(n) {
    var i, m, ref, res;
    if (n == null) {
      n = 1;
    }
    res = "" + this;
    for (i = m = 1, ref = n; 1 <= ref ? m < ref : m > ref; i = 1 <= ref ? ++m : --m) {
      res += "" + this;
    }
    return res;
  };

  String.prototype.encodeHTMLEntities = function() {
    return this.replace(/[\u00A0-\u9999<>\&]/gim, function(i) {
      return "&#" + (i.charCodeAt(0)) + ";";
    });
  };

  prototyping["Array::"] = {
    unique: function() {
      var elem, len1, m, res;
      res = [];
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        if (indexOf.call(res, elem) < 0) {
          res.push(elem);
        }
      }
      return res;
    },
    uniqueBy: function(propGetter, equals) {
      var done, duplicate, elem, len1, len2, m, o, res;
      if (propGetter == null) {
        propGetter = function(item) {
          return item;
        };
      }
      if (equals == null) {
        equals = function(a, b) {
          return a === b;
        };
      }
      res = [];
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        duplicate = false;
        for (o = 0, len2 = res.length; o < len2; o++) {
          done = res[o];
          if (!(equals(propGetter(done), propGetter(elem)))) {
            continue;
          }
          duplicate = true;
          break;
        }
        if (!duplicate) {
          res.push(elem);
        }
      }
      return res;
    },
    intersect: function(arr) {
      var elem;
      arr = arr;
      return ((function() {
        var len1, m, results;
        results = [];
        for (m = 0, len1 = this.length; m < len1; m++) {
          elem = this[m];
          if (indexOf.call(arr, elem) >= 0) {
            results.push(elem);
          }
        }
        return results;
      }).call(this)).unique();
    },
    intersects: function(arr) {
      return this.intersect(arr).length > 0;
    },
    groupBy: function(groupFun, equality) {
      var dict, elem, grouped, len1, m;
      dict = new App.Hash(null, equality);
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        grouped = groupFun(elem);
        if (dict.get(grouped) == null) {
          dict.put(grouped, []);
        }
        dict.get(grouped).push(elem);
      }
      return dict;
    },
    insert: function() {
      var elements, index;
      index = arguments[0], elements = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.splice.apply(this, [index, 0].concat(slice.call(elements)));
      return this;
    },
    remove: function() {
      var elem, elements, equals, idx, len1, len2, m, myElem, o, p, removeAllOccurences, removedElements;
      elements = 4 <= arguments.length ? slice.call(arguments, 0, m = arguments.length - 3) : (m = 0, []), equals = arguments[m++], removeAllOccurences = arguments[m++], removedElements = arguments[m++];
      if (removeAllOccurences == null) {
        removeAllOccurences = false;
      }
      if (equals == null) {
        equals = function(a, b) {
          return a === b;
        };
      }
      for (o = 0, len1 = elements.length; o < len1; o++) {
        elem = elements[o];
        for (idx = p = 0, len2 = this.length; p < len2; idx = ++p) {
          myElem = this[idx];
          if (!(equals(myElem, elem))) {
            continue;
          }
          if (removedElements != null) {
            removedElements.push(this.splice(idx, 1));
          }
          if (!removeAllOccurences) {
            break;
          }
        }
      }
      return this;
    },
    removeAt: function(idx) {
      this.splice(idx, 1);
      return this;
    },
    elemMoved: function(fromIdx, toIdx) {
      var e, elem, i, len1, m, res;
      res = [];
      elem = this[fromIdx];
      for (i = m = 0, len1 = this.length; m < len1; i = ++m) {
        e = this[i];
        if (!(i !== fromIdx)) {
          continue;
        }
        res.push(e);
        if (i === toIdx) {
          res.push(elem);
        }
      }
      return res;
    },
    flatten: function() {
      return Array.prototype.concat.apply([], this);
    },
    cloneDeep: function() {
      var elem, i, len1, m;
      for (i = m = 0, len1 = this.length; m < len1; i = ++m) {
        elem = this[i];
        if (elem instanceof Array) {
          this[i] = elem.cloneDeep();
        }
      }
      return this.clone();
    },
    except: function() {
      var el, elements;
      elements = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (function() {
        var len1, m, results;
        results = [];
        for (m = 0, len1 = this.length; m < len1; m++) {
          el = this[m];
          if (indexOf.call(elements, el) < 0) {
            results.push(el);
          }
        }
        return results;
      }).call(this);
    },

    /**
    * Returns the first element that fulfills the condition in a recursive search.
    * @param condition {Function}
    * @param getSubArray {Function}
    * Optional. If given, it's used to retrieve the next (lower) array for recursion.
    * Default: Go deeper only on elements that are arrays themselves.
    *
     */
    find: function(condition, getSubArray) {
      var item, len1, m, res, subArray;
      if (!(condition instanceof Function)) {
        condition = function(item) {
          return item === condition;
        };
      }
      if (getSubArray == null) {
        getSubArray = function(item) {
          return item;
        };
      }
      for (m = 0, len1 = this.length; m < len1; m++) {
        item = this[m];
        if (condition(item) === true) {
          return item;
        }
        if ((subArray = getSubArray(item)) instanceof Array) {
          if ((res = subArray.find(condition, getSubArray)) != null) {
            return res;
          }
        }
      }
      return null;
    },
    binIndexOf: function(searchElement) {
      var currentElement, currentIndex, maxIndex, minIndex;
      minIndex = 0;
      maxIndex = this.length - 1;
      while (minIndex <= maxIndex) {
        currentIndex = Math.floor((minIndex + maxIndex) / 2);
        currentElement = this[currentIndex];
        if (currentElement < searchElement) {
          minIndex = currentIndex + 1;
        } else if (currentElement > searchElement) {
          maxIndex = currentIndex - 1;
        } else {
          return currentIndex;
        }
      }
      return -1;
    },
    sortByProp: function(propGetter, order) {
      var cmpFunc;
      if (order == null) {
        order = "asc";
      }
      if (propGetter == null) {
        propGetter = function(item) {
          return item;
        };
      }
      if (order === "asc") {
        cmpFunc = function(a, b) {
          a = propGetter(a);
          b = propGetter(b);
          if (a < b) {
            return -1;
          }
          if (b < a) {
            return 1;
          }
          return 0;
        };
      } else {
        cmpFunc = function(a, b) {
          a = propGetter(a);
          b = propGetter(b);
          if (a > b) {
            return -1;
          }
          if (b > a) {
            return 1;
          }
          return 0;
        };
      }
      return this.sort(cmpFunc);
    },

    /**
     * @method getMax
     * @param {Function} propertyGetter
     * The passed callback extracts the value being compared from the array elements.
     * @return {Array} An array of all maxima.
    *
     */
    getMax: function(propertyGetter) {
      var elem, len1, m, max, res, val;
      max = null;
      res = [];
      if (propertyGetter == null) {
        propertyGetter = function(item) {
          return item;
        };
      }
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        val = propertyGetter(elem);
        if (val > max || max === null) {
          max = val;
          res = [elem];
        } else if (val === max) {
          res.push(elem);
        }
      }
      return res;
    },
    getMin: function(propertyGetter) {
      var elem, len1, m, min, res, val;
      min = null;
      res = [];
      if (propertyGetter == null) {
        propertyGetter = function(item) {
          return item;
        };
      }
      for (m = 0, len1 = this.length; m < len1; m++) {
        elem = this[m];
        val = propertyGetter(elem);
        if (val < min || min === null) {
          min = val;
          res = [elem];
        } else if (val === min) {
          res.push(elem);
        }
      }
      return res;
    },
    reverseCopy: function() {
      var item;
      return (function() {
        var m, results;
        results = [];
        for (m = this.length - 1; m >= 0; m += -1) {
          item = this[m];
          results.push(item);
        }
        return results;
      }).call(this);
    },
    sample: function(n, forceArray) {
      var arr, elem, i, res;
      if (n == null) {
        n = 1;
      }
      if (forceArray == null) {
        forceArray = false;
      }
      if (n === 1) {
        if (!forceArray) {
          return this[Math.floor(Math.random() * this.length)];
        }
        return [this[Math.floor(Math.random() * this.length)]];
      }
      if (n > this.length) {
        n = this.length;
      }
      i = 0;
      res = [];
      arr = this.clone();
      while (i++ < n) {
        elem = arr.sample(1);
        res.push(elem);
        arr.remove(elem);
      }
      return res;
    },
    shuffle: function() {
      var arr, elem, i, len1, m;
      arr = this.sample(this.length);
      for (i = m = 0, len1 = arr.length; m < len1; i = ++m) {
        elem = arr[i];
        this[i] = elem;
      }
      return this;
    },
    toObject: function(callback) {
      var elem, i, len1, len2, m, o, res;
      res = {};
      if (callback == null) {
        for (i = m = 0, len1 = this.length; m < len1; i = ++m) {
          elem = this[i];
          res[elem[0]] = elem[1];
        }
        return res;
      }
      for (i = o = 0, len2 = this.length; o < len2; i = ++o) {
        elem = this[i];
        elem = callback(elem);
        res[elem[0]] = elem[1];
      }
      return res;
    },
    swap: function(i, j) {
      var tmp;
      tmp = this[i];
      this[i] = this[j];
      this[j] = tmp;
      return this;
    },
    times: function(n) {
      var i, m, ref, res;
      res = this.clone();
      for (i = m = 1, ref = n; 1 <= ref ? m < ref : m > ref; i = 1 <= ref ? ++m : --m) {
        res = res.merge(this);
      }
      return res;
    },
    and: function(elem) {
      return this.concat([elem]);
    },
    merge: function(array) {
      Array.prototype.push.apply(this, array);
      return this;
    },
    noNulls: function() {
      var e, len1, m, res;
      res = [];
      for (m = 0, len1 = this.length; m < len1; m++) {
        e = this[m];
        if (!(e != null)) {
          continue;
        }
        res.push(e);
        return res;
      }
    },
    getLast: function(n) {
      if (n == null) {
        n = 1;
      }
      return this.slice(0, -n);
    },
    average: {
      get: function() {
        return Math.average.apply(null, this);
      },
      set: function() {}
    },
    last: {
      get: function() {
        return this[this.length - 1];
      },
      set: function(val) {
        this[this.length - 1] = val;
        return this;
      }
    },
    sum: {
      get: function() {
        var elem, len1, m, res;
        res = 0;
        for (m = 0, len1 = this.length; m < len1; m++) {
          elem = this[m];
          if (Math.isNum(elem)) {
            res += elem;
          }
        }
        return res;
      },
      set: function() {
        console.warn("[].sum is not settable!");
        return this;
      }
    },
    first: {
      get: function() {
        return this[0];
      },
      set: function(val) {
        this[0] = val;
        return this;
      }
    },
    second: {
      get: function() {
        return this[1];
      },
      set: function(val) {
        this[1] = val;
        return this;
      }
    },
    third: {
      get: function() {
        return this[2];
      },
      set: function(val) {
        this[2] = val;
        return this;
      }
    },
    fourth: {
      get: function() {
        return this[3];
      },
      set: function(val) {
        this[3] = val;
        return this;
      }
    },
    fifth: {
      get: function() {
        return this[4];
      },
      set: function(val) {
        this[4] = val;
        return this;
      }
    },
    sixth: {
      get: function() {
        return this[5];
      },
      set: function(val) {
        this[5] = val;
        return this;
      }
    },
    seventh: {
      get: function() {
        return this[6];
      },
      set: function(val) {
        this[6] = val;
        return this;
      }
    },
    eighth: {
      get: function() {
        return this[7];
      },
      set: function(val) {
        this[7] = val;
        return this;
      }
    },
    ninth: {
      get: function() {
        return this[8];
      },
      set: function(val) {
        this[8] = val;
        return this;
      }
    },
    tenth: {
      get: function() {
        return this[9];
      },
      set: function(val) {
        this[9] = val;
        return this;
      }
    },
    eleventh: {
      get: function() {
        return this[10];
      },
      set: function(val) {
        this[10] = val;
        return this;
      }
    },
    twelveth: {
      get: function() {
        return this[11];
      },
      set: function(val) {
        this[11] = val;
        return this;
      }
    }
  };

  Array.prototype.prepend = Array.prototype.unshift;

  Array.prototype.append = Array.prototype.push;

  Array.prototype.clone = Array.prototype.slice;

  Array.prototype.without = Array.prototype.except;

  $.fn.content = function(content) {
    var children, text;
    if (content != null) {
      if (typeof content === "string") {
        children = this.children().detach();
        this.empty().append(content).append(children);
      }
      return this;
    } else {
      children = this.children().detach();
      text = this.text();
      this.append(children);
      return text;
    }
  };

  $.fn.toggleAttr = function(attr, val1, val2) {
    var $elem, elem, len1, m;
    for (m = 0, len1 = this.length; m < len1; m++) {
      elem = this[m];
      $elem = $(elem);
      if ((val1 != null) && (val2 != null)) {
        $elem.attr("data-toggle-attr-val1", val1);
        $elem.attr("data-toggle-attr-val2", val2);
      } else {
        val1 = $elem.attr("data-toggle-attr-val1");
        val2 = $elem.attr("data-toggle-attr-val2");
      }
      if ($elem.attr(attr) === val1) {
        $elem.attr(attr, val2);
      } else {
        $elem.attr(attr, val1);
      }
    }
    return this;
  };

  $.fn.toggleCss = function(attr, val1, val2) {
    var $elem, elem, len1, m;
    for (m = 0, len1 = this.length; m < len1; m++) {
      elem = this[m];
      $elem = $(elem);
      if ((val1 != null) && (val2 != null)) {
        $elem.attr("data-toggle-css-val1", val1);
        $elem.attr("data-toggle-css-val2", val2);
      } else {
        val1 = $elem.attr("data-toggle-css-val1");
        val2 = $elem.attr("data-toggle-css-val2");
      }
      if ($elem.css(attr) === val1) {
        $elem.css(attr, val2);
      } else {
        $elem.css(attr, val1);
      }
    }
    return this;
  };

  $.fn.dimensions = function() {
    return {
      x: parseInt(this.width(), 10),
      y: parseInt(this.height(), 10)
    };
  };

  $.fn.outerDimensions = function(margins) {
    if (margins == null) {
      margins = true;
    }
    return {
      x: this.outerWidth(margins),
      y: this.outerHeight(margins)
    };
  };

  $.fn.showNow = function(display) {
    if (display == null) {
      display = "block";
    }
    this[0].style.display = display;
    return this;
  };

  $.fn.hideNow = function() {
    this[0].style.display = "none";
    return this;
  };

  $.fn.inDom = function() {
    return $.contains(document.documentElement, this[0]);
  };

  wrapAllOrig = $.fn.wrapAll;

  $.fn.wrapAll = function(wrapper) {
    if (this.inDom()) {
      return wrapAllOrig.call(this, wrapper);
    } else {
      if (!(wrapper instanceof $)) {
        wrapper = $(wrapper);
      }
      wrapper.append(this);
      return this;
    }
  };

  if ($.Color != null) {
    $.Color.fn.distanceTo = function(color, distFunc) {
      if (distFunc == null) {
        distFunc = function(c1, c2) {
          return Math.abs(c1.red() - c2.red()) + Math.abs(c1.green() - c2.green()) + Math.abs(c1.blue() - c2.blue());
        };
      }
      return distFunc(this, color);
    };
    $.Color.fn.isSimilarTo = function(color) {
      return this.distanceTo(color) / 255 < (1 - 1 / 1.61803398875);
    };
    $.Color.fn.toRgbaString = function() {
      return "rgba(" + this._rgba.join(",") + ")";
    };
  }

  for (setName in prototyping) {
    set = prototyping[setName];
    if (setName[setName.length - 1] === ":") {
      parent = window[setName.slice(0, -2)].prototype;
    } else {
      parent = window[setName];
    }
    if (!preferJSUtils) {
      for (methodName in set) {
        method = set[methodName];
        if (parent[methodName] != null) {
          methodName = "_" + methodName;
        }
        if (method instanceof Function) {
          Object.defineProperty(parent, methodName, {
            value: method,
            configurable: false,
            enumerable: false,
            writable: false
          });
        } else {
          Object.defineProperty(parent, methodName, method);
        }
      }
    } else {
      for (methodName in set) {
        method = set[methodName];
        if (parent[methodName] != null) {
          parent["_" + methodName] = parent[methodName];
        }
        if (method instanceof Function) {
          Object.defineProperty(parent, methodName, {
            value: method,
            configurable: false,
            enumerable: false,
            writable: false
          });
        } else {
          Object.defineProperty(parent, methodName, method);
        }
      }
    }
  }

  JSUtils.Tree = (function() {
    var CLASS;

    CLASS = Tree;


    /**
    * @method new
    * @static
    * @param node {Object}
    * @param options {Object}
    * Optional. Any given key will override the default. Here are the keys:
    * adjustLevels: Boolean value that indicates whether the tree is supposed to do its aftermath. Only set this to false if you're doing the aftermath later!!
    * afterInstantiate: Function to modify the node and/or the instance. Parameters are (1st) the node object and (2nd) the instance.
    * getChildren: Function that specifies how to retrieve the children from the node object.
    * getParent: Function that specifies how to retrieve the parent from the node object. getChildren is checked 1st so it doesn't make sense to pass getChildren AND getParent!
    * instantiate: Function that specifies how to create an instance from the node object. Parameter is the node object.
    *
     */

    Tree["new"] = function(node, options) {
      if (isFunction(node) && node instanceof this) {
        return new CLASS(node);
      }
      if (node.children != null) {
        return CLASS["new"].byChildRef(node);
      }
      if (node.parent != null) {
        return CLASS["new"].byParentRef(node);
      }
      if (options != null) {
        if (options.getChildren != null) {
          return CLASS["new"].byChildRef(node, options);
        }
        if (options.getParent != null) {
          return CLASS["new"].byParentRef(node, options);
        }
      }
      if (DEBUG) {
        console.warn("No recusrive structure found! Use correct options.");
      }
      return null;
    };


    /**
    * @method new.byChildRef
    * @static
    * @param node {Object}
    * @param options {Object}
    * Optional. Any given key will override the default. Here are the keys:
    * adjustLevels: Boolean value that indicates whether the tree is supposed to do its aftermath. Only set this to false if you're doing the aftermath later!!
    * afterInstantiate: Function to modify the node and/or the instance. Parameters are (1st) the node object and (2nd) the instance.
    * getChildren: Function that specifies how to retrieve the children from the node object.
    * instantiate: Function that specifies how to create an instance from the node object. Parameter is the node object.
    *
     */

    Tree["new"].byChildRef = function(node, options) {
      var adjustLevels, child, childInstance, defaultOptions, len1, m, ref, tree;
      defaultOptions = {
        getChildren: function(nodeData) {
          return nodeData.children;
        },
        instantiate: function(nodeData) {
          return new CLASS(nodeData);
        },
        afterInstantiate: function(nodeData, node) {
          return false;
        },
        adjustLevels: true
      };
      options = $.extend(defaultOptions, options);
      adjustLevels = options.adjustLevels;
      options.adjustLevels = false;
      tree = options.instantiate(node);
      options.afterInstantiate(node, tree);
      ref = options.getChildren(node) || [];
      for (m = 0, len1 = ref.length; m < len1; m++) {
        child = ref[m];
        childInstance = CLASS["new"].byChildRef(child, options);
        tree.addChild(childInstance, null, false);
      }
      if (adjustLevels) {
        tree.adjustLevels(0);
      }
      return tree;
    };


    /**
    * @method new.byParentRef
    * @static
    * @param node {Object}
    * @param options {Object}
    * Optional. Any given key will override the default. Here are the keys:
    * adjustLevels: Boolean value that indicates whether the tree is supposed to do its aftermath. Only set this to false if you're doing the aftermath later!!
    * afterInstantiate: Function to modify the node and/or the instance. Parameters are (1st) the node object and (2nd) the instance.
    * getParent: Function that specifies how to retrieve the parent from the node object.
    * instantiate: Function that specifies how to create an instance from the node object. Parameter is the node object.
    *
     */

    Tree["new"].byParentRef = function(node, getParent) {
      var tree;
      return tree = new CLASS();
    };

    Tree.fromRecursive = Tree["new"];

    function Tree(node) {
      var forbiddenKeys, k, self, v;
      self = this;
      this.children = [];
      this.parent = null;
      this.descendants = [];
      this.orderMode = "postorder";
      if (node == null) {
        this.data = {};
      } else {
        this.data = node.data || node;
        forbiddenKeys = Object.keys(this.constructor.prototype).concat(["children", "parent", "descendants", "data", "orderMode", "getClass", "getClassName", "constructor"]);
        for (k in node) {
          v = node[k];
          if (indexOf.call(forbiddenKeys, k) < 0) {
            if (!(v instanceof Function)) {
              (function(k, v) {
                return Object.defineProperty(self, k, {
                  get: function() {
                    return self.data[k];
                  },
                  set: function(val) {
                    self.data[k] = val;
                    return self;
                  }
                });
              })(k, v);
            } else {
              (function(k, v) {
                return self[k] = function() {
                  return v.call.apply(v, [node].concat(slice.call(arguments)));
                };
              })(k, v);
            }
          }
        }
      }
    }

    Object.defineProperties(Tree.prototype, {
      depth: {
        get: function() {
          return this.getDepth();
        },
        set: function() {
          return this;
        }
      },
      size: {
        get: function() {
          return this.getSize();
        },
        set: function() {
          return this;
        }
      },
      level: {
        get: function() {
          return this.getLevel();
        },
        set: function() {
          return this;
        }
      },
      root: {
        get: function() {
          return this.getRoot();
        },
        set: function() {
          return this;
        }
      }
    });

    Tree.prototype._cacheDescendants = function() {
      var child, len1, m, ref, res;
      res = [];
      ref = this.children;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        child = ref[m];
        child._cacheDescendants();
        res = res.concat(child.descendants);
      }
      this.descendants = this.children.concat(res);
      return this;
    };

    Tree.prototype.equals = function(tree, compareLeaves) {
      var idx, len1, len2, m, match, myChild, o, otherChild, otherChildren, ref;
      if (this.children.length > 0) {
        if (this.children.length !== tree.children.length || this.descendants.length !== tree.descendants.length) {
          return false;
        }
        otherChildren = tree.children.clone();
        ref = this.children;
        for (m = 0, len1 = ref.length; m < len1; m++) {
          myChild = ref[m];
          match = false;
          for (idx = o = 0, len2 = otherChildren.length; o < len2; idx = ++o) {
            otherChild = otherChildren[idx];
            if (!(myChild.equals(otherChild))) {
              continue;
            }
            match = true;
            break;
          }
          if (!match) {
            return false;
          }
          otherChildren.splice(idx, 1);
        }
        return true;
      }
      if (compareLeaves instanceof Function) {
        return compareLeaves(this, tree);
      }
      return true;
    };

    Tree.prototype.hasNode = function(node) {
      return this === node || indexOf.call(this.descendants, node) >= 0;
    };


    /**
    * Find (first occurence of) a node
    * @method findNode
    * @param equalsFunction {Function}
    *
     */

    Tree.prototype.findNode = function(filter) {
      var ref;
      return ((ref = this.findNodes(filter)) != null ? ref.first : void 0) || null;
    };

    Tree.prototype.findDescendant = function() {
      return this.findNode.apply(this, arguments);
    };


    /**
    * Find all occurences of a node.
    * @method findNodes
    * @param equalsFunction {JSUtils.Tree}
    *
     */

    Tree.prototype.findNodes = function(param) {
      var len1, m, node, ref, res;
      res = [];
      if (param instanceof Function) {
        ref = this.descendants;
        for (m = 0, len1 = ref.length; m < len1; m++) {
          node = ref[m];
          if (param(node)) {
            res.push(node);
          }
        }
      }
      return res;
    };

    Tree.prototype.findDescendants = function() {
      return this.findNodes.apply(this, arguments);
    };

    Tree.prototype.getDepth = function() {
      var maxLevel;
      if (this.children.length > 0) {
        maxLevel = this.descendants.getMax(function(node) {
          return node.level;
        });
        return maxLevel.first.level - this.level;
      }
      return 0;
    };


    /**
    * Get number of nodes in (sub)tree
    *
     */

    Tree.prototype.getSize = function() {
      return this.descendants.length + 1;
    };

    Tree.prototype.getLevel = function() {
      return this._level;
    };

    Tree.prototype.getRoot = function() {
      var root;
      if ((root = this.parent) == null) {
        return this;
      }
      while (root.parent != null) {
        root = root.parent;
      }
      return root;
    };

    Tree.prototype.getLeaves = function() {
      var child, leaves, len1, m, ref;
      leaves = [];
      ref = this.children;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        child = ref[m];
        if (child.children.length > 0) {
          leaves.merge(child.getLeaves());
        } else {
          leaves.push(child);
        }
      }
      return leaves;
    };

    Tree.prototype.isLeaf = function() {
      return this.children.length === 0;
    };


    /**
    * Serialize the tree to a plain object.
    *
     */

    Tree.prototype.serialize = function(format, doneNodes) {
      var base, base1, child, len1, m, ref, serializedChildren;
      if (doneNodes == null) {
        doneNodes = [];
      }
      serializedChildren = [];
      ref = this.children;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        child = ref[m];
        if (!(indexOf.call(doneNodes, child) < 0)) {
          continue;
        }
        doneNodes.push(child);
        serializedChildren.push(child.serialize(format, doneNodes));
      }
      if (format == null) {
        return {
          children: serializedChildren,
          data: (typeof (base = this.data).serialize === "function" ? base.serialize() : void 0) || JSON.parse(JSON.stringify(this.data))
        };
      }
      return format(this, serializedChildren, (typeof (base1 = this.data).serialize === "function" ? base1.serialize() : void 0) || JSON.parse(JSON.stringify(this.data)));
    };

    Tree.prototype.deserialize = function(data) {
      var key, len1, m, tree, val;
      tree = this.constructor["new"](data);
      this.children = tree.children;
      for (val = m = 0, len1 = data.length; m < len1; val = ++m) {
        key = data[val];
        if (key !== "children") {
          this[key] = val;
        }
      }
      return this;
    };

    Tree.prototype.toObject = function() {
      return this.serialize();
    };

    Tree.prototype.pathToRoot = function() {
      var res;
      res = [this];
      parent = this.parent;
      while (parent != null) {
        res.push(parent);
        parent = parent.parent;
      }
      res.reverse();
      return res;
    };

    Tree.prototype.getSiblings = function() {
      var ref;
      return ((ref = this.parent) != null ? ref.children.except(this) : void 0) || [];
    };

    Tree.prototype.getLevelSiblings = function() {
      var ref, self, siblings;
      self = this;
      siblings = (ref = this.getRoot()) != null ? ref.findNodes(function(node) {
        return node.level === self.level && node !== self;
      }) : void 0;
      return siblings || [];
    };

    Tree.prototype.getParent = function() {
      return this.parent;
    };

    Tree.prototype.getChildren = function() {
      return this.children;
    };

    Tree.prototype.addChild = function(node, index, adjustLevels) {
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      if (!node.instanceOf(JSUtils.Tree)) {
        node = new CLASS(node);
      }
      if ((node.parent != null) && node.parent !== this) {
        node.moveTo(this, index);
        return this;
      }
      if (index == null) {
        this.children.push(node);
      } else {
        this.children.insert(index, node);
      }
      node.parent = this;
      if (adjustLevels) {
        node.adjustLevels(this.level);
      }
      return this;
    };

    Tree.prototype.appendChild = function() {
      return this.addChild.apply(this, arguments);
    };

    Tree.prototype.addChildren = function(nodes, index, adjustLevels) {
      var m, node;
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      for (m = nodes.length - 1; m >= 0; m += -1) {
        node = nodes[m];
        if (node != null) {
          this.addChild(node, index, false);
        }
      }
      if (adjustLevels) {
        this.adjustLevels(this.level);
      }
      return this;
    };

    Tree.prototype.appendChildren = function() {
      return this.addChildren.apply(this, arguments);
    };

    Tree.prototype.setChildren = function(nodes, clone, adjustLevels) {
      var len1, m, node;
      if (clone == null) {
        clone = false;
      }
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      this.children = [];
      if (clone) {
        nodes = (function() {
          var len1, m, results;
          results = [];
          for (m = 0, len1 = nodes.length; m < len1; m++) {
            node = nodes[m];
            if (node != null) {
              results.push(node.clone());
            }
          }
          return results;
        })();
      }
      for (m = 0, len1 = nodes.length; m < len1; m++) {
        node = nodes[m];
        this.addChild(node, false);
      }
      if (adjustLevels) {
        this.adjustLevels(this.level);
      }
      return this;
    };

    Tree.prototype.moveTo = function(targetNode, index, adjustLevels) {
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      this.remove(false);
      targetNode.addChild(this, index, adjustLevels);
      return this;
    };

    Tree.prototype.remove = function(adjustLevels) {
      if (adjustLevels == null) {
        adjustLevels = true;
      }
      if (this.parent != null) {
        this.parent.children = this.parent.children.except(this);
        this.parent.descendants = this.parent.descendants.except(this.descendants.and(this));
        this.parent = null;
        if (adjustLevels) {
          this.adjustLevels();
        }
      }
      return this;
    };

    Tree.prototype.removeChild = function(node) {
      if (indexOf.call(this.children, node) >= 0) {
        node.remove();
      }
      return this;
    };

    Tree.prototype.removeChildAt = function(idx) {
      return removeChild(this.children[idx]);
    };

    Tree.prototype.appendTo = function(node) {
      return node.addChild(this);
    };

    Tree.prototype.adjustLevels = function(startLevel) {
      if (startLevel == null) {
        startLevel = 0;
      }
      this._cacheDescendants().each(function(n, l, i) {
        n._level = startLevel + l;
        return true;
      });
      return this;
    };


    /**
    * @method traverse
    * @param callback {Function}
    * Gets the current node, the current level relative to the root of the current traversal, and iteration index as parameters.
    * @param orderMode {String}
    * Optional. Default is "postorder". Possible are "postorder", "preorder", "inorder", "levelorder".
    * @param searchMode {String}
    * Optional. Default is "depthFirst". Posible are "depthFirst", "breadthFirst".
    *
     */

    Tree.prototype.traverse = function(callback, orderMode, inorderIndex) {
      if (orderMode == null) {
        orderMode = this.orderMode || "postorder";
      }
      if (inorderIndex == null) {
        inorderIndex = null;
      }
      return this[orderMode](callback, null, inorderIndex);
    };

    Tree.prototype.each = function() {
      return this.traverse.apply(this, arguments);
    };

    Tree.prototype.postorder = function(callback, level, info) {
      var child, len1, m, ref;
      if (level == null) {
        level = 0;
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this
        };
      }
      ref = this.children;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        child = ref[m];
        child.postorder(callback, level + 1, info);
        info.idx++;
      }
      if (callback.call(info.ctx, this, level, info.idx) === false) {
        return this;
      }
      return this;
    };

    Tree.prototype.preorder = function(callback, level, info) {
      var child, len1, m, ref;
      if (level == null) {
        level = 0;
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this
        };
      }
      if (callback.call(info.ctx, this, level, info.idx) === false) {
        return this;
      }
      ref = this.children;
      for (m = 0, len1 = ref.length; m < len1; m++) {
        child = ref[m];
        child.preorder(callback, level + 1, info);
        info.idx++;
      }
      return this;
    };

    Tree.prototype.inorder = function(callback, level, index, info) {
      var i, m, o, ref, ref1, ref2;
      if (index == null) {
        index = Math.floor(this.children.length / 2);
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this
        };
      }
      for (i = m = 0, ref = index; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
        this.children[i].inorder(callback, level + 1, index, info);
        info.idx++;
      }
      if (callback.call(info.ctx, this, level, info.idx) === false) {
        return this;
      }
      for (i = o = ref1 = index, ref2 = this.children.lenth; ref1 <= ref2 ? o < ref2 : o > ref2; i = ref1 <= ref2 ? ++o : --o) {
        this.children[i].inorder(callback, level + 1, index, info);
        info.idx++;
      }
      return this;
    };

    Tree.prototype.levelorder = function(callback, level, info) {
      var currentLevel, el, list, prevLevel, startLevel;
      if (level == null) {
        level = 0;
      }
      if (info == null) {
        info = {
          idx: 0,
          ctx: this,
          levelIdx: 0
        };
      }
      list = [this];
      startLevel = this.level;
      prevLevel = 0;
      while (list.length > 0) {
        el = list.shift();
        currentLevel = el.level - startLevel;
        if (currentLevel > prevLevel) {
          info.levelIdx = 0;
        }
        if (callback.call(info.ctx, el, currentLevel, info) === false) {
          return this;
        }
        prevLevel = currentLevel;
        info.idx++;
        info.levelIdx++;
        list = list.concat(el.children);
      }
      return this;
    };

    return Tree;

  })();

  JSUtils.Leaf = (function(superClass) {
    var CLASS;

    extend(Leaf, superClass);

    CLASS = Leaf;

    Leaf["new"] = function(node) {
      return new this(node);
    };

    function Leaf(node) {
      Leaf.__super__.constructor.call(this, node);
      delete this.children;
      Object.defineProperty(this, "children", {
        get: function() {
          return [];
        },
        set: function() {
          throw new Error("JSUtils.Leaf::children=: Cannot set children of a leaf!");
        }
      });
    }

    Leaf.prototype._cacheDescendants = function() {
      return this;
    };

    Leaf.prototype.findNodes = function(param) {
      return null;
    };

    Leaf.prototype.getDepth = function() {
      return 0;
    };

    Leaf.prototype.getSize = function() {
      return 0;
    };

    Leaf.prototype.getLevel = function() {
      return this._level;
    };

    Leaf.prototype.getLeaves = function() {
      return [];
    };

    Leaf.prototype.isLeaf = function() {
      return true;
    };

    Leaf.prototype.serialize = function(format) {
      var base, base1;
      if (format == null) {
        return {
          children: [],
          data: (typeof (base = this.data).serialize === "function" ? base.serialize() : void 0) || JSON.parse(JSON.stringify(this.data))
        };
      }
      return format(this, [], (typeof (base1 = this.data).serialize === "function" ? base1.serialize() : void 0) || JSON.parse(JSON.stringify(this.data)));
    };

    Leaf.prototype.deserialize = function(data) {
      this.data = data;
      return this;
    };

    Leaf.prototype.getChildren = function() {
      return [];
    };

    Leaf.prototype.addChild = function() {
      throw new Error("JSUtils.Leaf::addChild: Cannot add a child to a leaf!");
    };

    Leaf.prototype.addChildren = function() {
      throw new Error("JSUtils.Leaf::addChildren: Cannot add children to a leaf!");
    };

    Leaf.prototype.setChildren = function() {
      throw new Error("JSUtils.Leaf::setChildren: Cannot set children of a leaf!");
    };

    Leaf.prototype.removeChild = function() {
      throw new Error("JSUtils.Leaf::removeChild: Cannot remove children of a leaf!");
    };

    Leaf.prototype.removeChildAt = function(idx) {
      throw new Error("JSUtils.Leaf::removeChildAt: Cannot remove children of a leaf!");
    };

    Leaf.prototype.adjustLevels = function() {
      return this;
    };

    return Leaf;

  })(JSUtils.Tree);

}).call(this);
