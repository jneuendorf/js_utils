// Generated by CoffeeScript 1.9.1
(function() {
  var __NULL__, _super, _superStatic, classFromObject, each, execSuper, inherit, mergeMRO, slice, toArray,
    slice1 = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  __NULL__ = {};

  slice = Array.prototype.slice;

  toArray = function(args) {
    return slice.call(args);
  };

  each = function(arr, callback) {
    var elem, idx, j, len;
    for (idx = j = 0, len = arr.length; j < len; idx = ++j) {
      elem = arr[idx];
      if (callback(elem, idx) === false) {
        return arr;
      }
    }
    return arr;
  };

  execSuper = function(clss, name, dest, args) {
    var f;
    if ((f = dest[name]) == null) {
      return __NULL__;
    }
    if (!f.__class__ || !f.__name__) {
      f.__class__ = clss;
      f.__name__ = name;
    }
    if (typeof f === "function") {
      return f.apply(this, args);
    }
    return f;
  };

  _super = function() {
    var MRO, args, c, clss, j, len, name, ref, res;
    clss = arguments[0], name = arguments[1], args = 3 <= arguments.length ? slice1.call(arguments, 2) : [];
    MRO = this.constructor.__mro__;
    ref = MRO.slice(MRO.indexOf(clss) + 1);
    for (j = 0, len = ref.length; j < len; j++) {
      c = ref[j];
      if ((res = execSuper.call(this, c, name, c.prototype, args)) !== __NULL__) {
        return res;
      }
      if (name === Halo.config.constructorName) {
        return c.apply(this, args);
      }
    }
    console.warn("There is no 'this._super()' for the following function:", name, "of", (clss.__name__ !== Halo.config.constructorName ? clss.__name__ : clss.name), "(in MRO of " + this.constructor.name + ")");
    return args[0] || null;
  };

  _superStatic = function() {
    var MRO, args, c, clss, j, len, name, ref, res;
    clss = arguments[0], name = arguments[1], args = 3 <= arguments.length ? slice1.call(arguments, 2) : [];
    MRO = this.__mro__;
    ref = MRO.slice(MRO.indexOf(clss) + 1);
    for (j = 0, len = ref.length; j < len; j++) {
      c = ref[j];
      if ((res = execSuper.call(this, c, name, c, args)) !== __NULL__) {
        return res;
      }
    }
    console.warn("There is no 'this._super()' for the following function:", name, "of", clss.__name__, "(in MRO of " + this.name + ")");
    return args[0] || null;
  };

  classFromObject = function(name, obj) {
    var clss, ctorStr, j, key, len, o, ref, val;
    if (obj.hasOwnProperty("constructor")) {
      ctorStr = obj.constructor.toString().replace("function ", "function " + name).replace(/\n/g, "");
    } else {
      ctorStr = "function " + name + "(){ this._super.apply(this, arguments) }";
    }
    clss = eval("(" + ctorStr + ")");
    clss.__class__ = clss;
    clss.__name__ = Halo.config.constructorName;
    clss.__mro__ = [];
    for (key in obj) {
      val = obj[key];
      if (!(indexOf.call(["constructor"].concat(Halo.config.staticKeys), key) < 0)) {
        continue;
      }
      val.__name__ = key;
      val.__class__ = clss;
      clss.prototype[key] = val;
    }
    ref = Halo.config.staticKeys;
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      if ((o = obj[key]) != null) {
        for (key in o) {
          val = o[key];
          val.__name__ = key;
          val.__class__ = clss;
          clss[key] = val;
        }
      }
    }
    clss.prototype._super = function() {
      var caller;
      caller = arguments.callee.caller;
      return _super.apply(this, [caller.__class__, caller.__name__].concat(toArray(arguments)));
    };
    clss._super = function() {
      var caller;
      caller = arguments.callee.caller;
      return _superStatic.apply(this, [caller.__class__, caller.__name__].concat(toArray(arguments)));
    };
    return clss;
  };

  mergeMRO = function(toMerge) {
    var __mro__, cur, current, currentClass, found, i, isInTail, j, k, len, len1, lst, valid;
    __mro__ = [];
    current = toMerge.slice(0);
    while (true) {
      found = false;
      i = -1;
      while (++i < current.length) {
        cur = current[i];
        if (cur.length === 0) {
          continue;
        }
        currentClass = cur[0];
        isInTail = false;
        for (j = 0, len = current.length; j < len; j++) {
          lst = current[j];
          if (!(indexOf.call(lst.slice(1), currentClass) >= 0)) {
            continue;
          }
          isInTail = true;
          break;
        }
        if (!isInTail) {
          found = true;
          __mro__.push(currentClass);
          current = (function() {
            var k, len1, results;
            results = [];
            for (k = 0, len1 = current.length; k < len1; k++) {
              lst = current[k];
              if (lst[0] === currentClass) {
                results.push(lst.slice(1));
              } else {
                results.push(lst);
              }
            }
            return results;
          })();
          break;
        }
      }
      if (found) {
        continue;
      }
      valid = true;
      for (k = 0, len1 = current.length; k < len1; k++) {
        i = current[k];
        if (!(i.length !== 0)) {
          continue;
        }
        valid = false;
        break;
      }
      if (valid) {
        return __mro__;
      }
    }
  };

  inherit = function(source, dest, clss, _super, ctx) {
    var claz, key, ref, val;
    for (key in source) {
      val = source[key];
      ref = val, val = ref[0], claz = ref[1];
      if (val instanceof Function) {
        dest[key] = (function(key, claz) {
          var f;
          f = function() {
            return _super.apply(ctx || this, [clss, key].concat(toArray(arguments)));
          };
          f.__name__ = key;
          return f;
        })(key, claz);
      } else {
        dest[key] = val;
      }
    }
  };

  window.Halo = {
    config: {
      staticKeys: ["@", "static"],
      constructorName: "__ctor__"
    }
  };


  /*
  Halo.create([parents,] name, properties)
  Creates a new class and returns it.
   */

  Halo.create = function(parents, name, data) {
    var MRO, clss, parent, proto, protoVars, reversedMRO, selfProtoKeys, selfStaticKeys, staticVars;
    if (parents == null) {
      parents = [];
    } else if (typeof parents === "string") {
      data = name;
      name = parents;
      parents = [];
    } else if (!(parents instanceof Array)) {
      parents = [parents];
    }
    if (data instanceof Function) {
      clss = data;
    } else if (data instanceof Object) {
      clss = classFromObject(name, data);
    } else {
      throw new Error("Invalid data passed:", data);
    }
    MRO = [clss].concat(mergeMRO(((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = parents.length; j < len; j++) {
        parent = parents[j];
        results.push(parent.__mro__ || []);
      }
      return results;
    })()).concat([parents])));
    proto = clss.prototype;
    selfStaticKeys = Object.keys(clss);
    selfProtoKeys = Object.keys(proto);
    staticVars = {};
    protoVars = {};
    reversedMRO = MRO.slice(1).reverse();
    each(reversedMRO, function(claz, i) {
      var j, k, key, len, len1, protoKeys, staticKeys;
      staticKeys = Object.keys(claz);
      protoKeys = Object.keys(claz.prototype);
      for (j = 0, len = staticKeys.length; j < len; j++) {
        key = staticKeys[j];
        if (indexOf.call(selfStaticKeys, key) < 0) {
          staticVars[key] = [claz[key], claz];
        }
      }
      for (k = 0, len1 = protoKeys.length; k < len1; k++) {
        key = protoKeys[k];
        if (indexOf.call(selfProtoKeys, key) < 0) {
          protoVars[key] = [claz.prototype[key], claz];
        }
      }
      return true;
    });
    inherit(staticVars, clss, clss, _superStatic, clss);
    inherit(protoVars, proto, clss, _super, null);
    clss.__mro__ = MRO;
    return clss;
  };

}).call(this);
