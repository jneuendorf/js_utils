// Generated by CoffeeScript 1.10.0
(function() {
  var slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  window.DEBUG = true;

  describe("async", function() {
    describe("Sequence", function() {
      beforeEach(function() {
        var Helper;
        this.sequence = new JSUtils.Sequence([], false);
        Helper = (function() {
          function Helper(delay) {
            if (delay == null) {
              delay = 100;
            }
            this.cbs = [];
            this.isDone = false;
            this.delay = delay;
          }

          Helper.prototype.go = function(result) {
            return window.setTimeout((function(_this) {
              return function() {
                _this.isDone = true;
                if (result != null) {
                  result.push(_this.delay);
                }
                return _this._done();
              };
            })(this), this.delay);
          };

          Helper.prototype._done = function() {
            var cb, j, len, ref, results;
            ref = this.cbs;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              cb = ref[j];
              results.push(cb());
            }
            return results;
          };

          Helper.prototype.done = function(cb) {
            this.cbs.push(cb);
            if (this.isDone) {
              this._done();
            }
            return this;
          };

          return Helper;

        })();
        return this.helperClass = Helper;
      });
      it("static method setTimeout behaves like a sequence", function(done) {
        var checkpoints, start;
        checkpoints = [];
        start = Date.now();
        JSUtils.Sequence.setTimeout(function() {
          checkpoints.push(1);
          return expect(Math.round((Date.now() - start) / 10)).toBe(10);
        }, 100);
        JSUtils.Sequence.setTimeout(function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          expect(args).toEqual([1, 2]);
          expect(this).toEqual({
            scope: true
          });
          expect(checkpoints).toEqual([1]);
          return done();
        }, 300, {
          scope: true
        }, [1, 2]);
        return expect(checkpoints).toEqual([]);
      });
      it("execute synchronous functions in correct order", function(done) {
        var result;
        result = [];
        this.sequence.start([
          {
            func: function() {
              return result.push("func1");
            }
          }, {
            func: function() {
              return result.push("func2");
            }
          }, [
            function() {
              return result.push("func3");
            }
          ]
        ]);
        return this.sequence.done(function() {
          expect(result).toEqual(["func1", "func2", "func3"]);
          return done();
        });
      });
      it("execute asynchronous in correct order", function(done) {
        var Helper, result;
        result = [];
        Helper = this.helperClass;
        this.sequence.start([
          {
            func: function() {
              var h;
              h = new Helper(300);
              h.go(result);
              return h;
            }
          }, {
            func: function() {
              var h;
              h = new Helper(100);
              h.go(result);
              return h;
            }
          }, [
            function() {
              var h;
              h = new Helper(150);
              h.go(result);
              return h;
            }
          ]
        ]);
        return this.sequence.done(function() {
          expect(result).toEqual([300, 100, 150]);
          return done();
        });
      });
      it("apply different contexts to sequence functions", function(done) {
        var result, self;
        result = [];
        this.sequence.start([
          {
            func: function() {
              return result.push(this);
            },
            scope: window
          }, {
            func: function() {
              return result.push(this);
            },
            scope: this
          }
        ]);
        self = this;
        return this.sequence.done(function() {
          expect(result[0] === window).toBe(true);
          expect(result[1] === self).toBe(true);
          return done();
        });
      });
      it("access previous results", function(done) {
        this.sequence.start([
          {
            func: function() {
              return 2;
            }
          }, {
            func: function(a) {
              return a + 8;
            },
            scope: this
          }
        ]);
        return this.sequence.done(function(lastResult) {
          expect(lastResult).toBe(10);
          return done();
        });
      });
      it("execute done-callbacks on completion and aftewards", function(done) {
        var result;
        result = [];
        this.sequence.start([
          {
            func: function() {
              return 2;
            }
          }, {
            func: function(a) {
              return a + 8;
            },
            scope: this
          }
        ]);
        return this.sequence.done((function(_this) {
          return function(lastResult) {
            result.push("first");
            return _this.sequence.done(function() {
              result.push("second");
              expect(result).toEqual(["first", "second"]);
              return done();
            });
          };
        })(this));
      });
      it("nested sequences (and previous result access)", function(done) {
        var result;
        result = [];
        this.sequence.start([
          {
            func: function() {
              return result.push("func1");
            }
          }, {
            func: function() {
              result.push("func2");
              return new JSUtils.Sequence([
                {
                  func: function() {
                    result.push("func2.1");
                    return 2;
                  }
                }, {
                  func: function(shouldBeTwo) {
                    result.push("func2.2 -> " + shouldBeTwo);
                    return shouldBeTwo * 3;
                  }
                }
              ]);
            }
          }, [
            function(shouldBeSix) {
              return result.push("func3 -> " + shouldBeSix);
            }
          ]
        ]);
        return this.sequence.done(function() {
          expect(result).toEqual(["func1", "func2", "func2.1", "func2.2 -> 2", "func3 -> 6"]);
          return done();
        });
      });
      it("stopping (no more functions in sequence will be executed, callbacks will fire)", function(done) {
        var Helper, h1, result;
        result = [];
        Helper = this.helperClass;
        h1 = null;
        this.sequence.start([
          {
            func: function() {
              h1 = new Helper(300);
              h1.go(result);
              h1.done((function(_this) {
                return function() {
                  return _this.sequence.stop();
                };
              })(this));
              return h1;
            },
            scope: this
          }, {
            func: function() {
              var h;
              h = new Helper(100);
              h.go(result);
              return h;
            }
          }, [
            function() {
              var h;
              h = new Helper(150);
              h.go(result);
              return h;
            }
          ]
        ]);
        return this.sequence.done(function() {
          expect(result).toEqual([300]);
          return done();
        });
      });
      it("interrupting (no more functions in sequence will be executed, callbacks will NOT fire)", function(done) {
        var Helper, h1, result;
        result = [];
        Helper = this.helperClass;
        h1 = null;
        this.sequence.start([
          {
            func: function() {
              h1 = new Helper(300);
              h1.go(result);
              h1.done((function(_this) {
                return function() {
                  _this.sequence.interrupt();
                  return window.setTimeout(function() {
                    expect(result).toEqual([300]);
                    return done();
                  }, 200);
                };
              })(this));
              return h1;
            },
            scope: this
          }, {
            func: function() {
              var h;
              h = new Helper(100);
              h.go(result);
              return h;
            }
          }, [
            function() {
              var h;
              h = new Helper(150);
              h.go(result);
              return h;
            }
          ]
        ]);
        return this.sequence.done(function() {
          return result.push("should not be in result!");
        });
      });
      it("stopping & interrupting on error", function(done) {
        var Helper, errorFunc, result, self;
        self = this;
        result = [];
        Helper = this.helperClass;
        errorFunc = function() {
          throw new Error("Whatever!");
        };
        this.sequence.onError(function(error, sequenceData, index) {
          expect(result).toEqual([300]);
          expect(this).toBe(self.sequence);
          expect(error.message).toBe("Whatever!");
          expect(sequenceData.func).toBe(errorFunc);
          expect(index).toBe(1);
          return done();
        });
        return this.sequence.start([
          {
            func: function() {
              var h;
              h = new Helper(300);
              h.go(result);
              return h;
            }
          }, {
            func: errorFunc
          }, [
            function() {
              var h;
              h = new Helper(150);
              h.go(result);
              return h;
            }
          ]
        ]);
      });
      it("returning a doneable object will also make it accessible in the next function", function(done) {
        var Helper, h, result;
        result = [];
        Helper = this.helperClass;
        h = null;
        this.sequence.start([
          {
            func: function() {
              h = new Helper(300);
              h.go();
              return h;
            },
            scope: this
          }, {
            func: function(prevH) {
              result.push(prevH === h);
              return null;
            }
          }, {
            func: function(nully) {
              return result.push(nully === null);
            }
          }
        ]);
        return this.sequence.done(function() {
          expect(result).toEqual([true, true]);
          return done();
        });
      });
      it("use context to pass multiple parameters to next function in sequence", function(done) {
        var Helper, result;
        result = [];
        Helper = this.helperClass;
        this.sequence.start([
          {
            func: function() {
              var h;
              h = new Helper(300);
              h.go();
              return {
                done: h,
                context: {
                  a: 1,
                  b: 2
                }
              };
            },
            scope: this
          }, {
            func: function(b, a) {
              var h;
              result.push([b, a]);
              h = new Helper(100);
              h.go();
              return {
                done: h,
                context: ["a", "b", "c"]
              };
            }
          }, [
            function(x, y, z) {
              var h;
              result.push([x, y, z]);
              h = new Helper(150);
              h.go();
              return h;
            }
          ]
        ]);
        return this.sequence.done(function() {
          expect(result).toEqual([[2, 1], ["a", "b", "c"]]);
          return done();
        });
      });
      it("use context to pass multiple parameters to next function in outer sequence", function(done) {
        return this.sequence.start([
          {
            func: function() {
              return new JSUtils.Sequence([
                {
                  func: function() {
                    return {
                      context: {
                        a: 1,
                        b: 2
                      }
                    };
                  }
                }
              ]);
            }
          }, {
            func: function(a, b) {
              expect(a === 1 && b === 2).toBe(true);
              return done();
            }
          }
        ]);
      });
      it("while", function(done) {
        var result;
        result = [];
        this.sequence["while"](function() {
          return result.push("very first");
        }, function() {
          expect(result).toEqual(["very first", "func1", "func2", "func3"]);
          return done();
        });
        return this.sequence.start([
          {
            func: function() {
              return result.push("func1");
            }
          }, {
            func: function() {
              return result.push("func2");
            }
          }, [
            function() {
              return result.push("func3");
            }
          ]
        ]);
      });
      it("progress", function(done) {
        var result, sequence;
        result = [];
        sequence = this.sequence;
        expect(sequence.progress()).toBe(1);
        sequence.start([
          {
            func: function() {
              return result.push(sequence.progress());
            }
          }, {
            func: function() {
              return result.push(sequence.progress());
            }
          }, [
            function() {
              return result.push(sequence.progress());
            }
          ]
        ]);
        return sequence.done(function() {
          result.push(sequence.progress());
          expect(result).toEqual([0, 1 / 3, 2 / 3, 1]);
          return done();
        });
      });
      it("addData", function() {
        var checkpoints;
        this.sequence.start();
        expect(this.sequence.progress()).toBe(1);
        checkpoints = [];
        this.sequence.addData([
          {
            func: function() {
              checkpoints.push(1);
              return 1;
            }
          }
        ]);
        expect(checkpoints).toEqual([1]);
        this.sequence.addData([
          {
            func: (function(_this) {
              return function() {
                checkpoints.push(2);
                _this.sequence.interrupt();
                return 2;
              };
            })(this)
          }, {
            func: function() {
              checkpoints.push(3);
              return 3;
            }
          }
        ], false);
        expect(checkpoints).toEqual([1]);
        expect(this.sequence._isDone).toBe(false);
        this.sequence.addData([
          {
            func: function() {
              checkpoints.push(4);
              return 4;
            }
          }
        ]);
        expect(checkpoints).toEqual([1, 2]);
        expect(this.sequence._isStopped).toBe(true);
        this.sequence.addData([
          {
            func: function() {
              checkpoints.push(5);
              return 5;
            }
          }
        ]);
        expect(this.sequence._isStopped).toBe(false);
        return expect(this.sequence._isDone).toBe(true);
      });
      return it("can take plain functions as data", function() {
        var checkpoints;
        checkpoints = [];
        this.sequence.start([
          function() {
            checkpoints.push(1);
            return 1;
          }, function() {
            checkpoints.push(2);
            return 2;
          }
        ]);
        return expect(checkpoints).toEqual([1, 2]);
      });
    });
    return describe("Barrier", function() {
      beforeEach(function() {
        var Helper;
        this.barrier = new JSUtils.Barrier([], false);
        Helper = (function() {
          function Helper(delay) {
            if (delay == null) {
              delay = 1000;
            }
            this.cbs = [];
            this.isDone = false;
            this.delay = delay;
          }

          Helper.prototype.go = function(result) {
            return window.setTimeout((function(_this) {
              return function() {
                _this.isDone = true;
                if (result != null) {
                  result.push(_this.delay);
                }
                return _this._done();
              };
            })(this), this.deplay);
          };

          Helper.prototype._done = function() {
            var cb, j, len, ref, results;
            ref = this.cbs;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              cb = ref[j];
              results.push(cb());
            }
            return results;
          };

          Helper.prototype.done = function(cb) {
            this.cbs.push(cb);
            if (this.isDone) {
              this._done();
            }
            return this;
          };

          return Helper;

        })();
        return this.helperClass = Helper;
      });
      it("execute synchronous functions pseudo-concurrently", function(done) {
        this.barrier.start([
          {
            func: function() {
              return 2;
            }
          }, {
            func: function() {
              return 8;
            }
          }
        ]);
        return this.barrier.done(function(barrierResults) {
          expect(barrierResults).toEqual([2, 8]);
          return done();
        });
      });
      it("execute asynchronous functions pseudo-concurrently", function(done) {
        var Helper, result;
        result = [];
        Helper = this.helperClass;
        this.barrier.start([
          {
            func: function() {
              var h;
              h = new Helper(3000);
              h.go(result);
              return h;
            }
          }, {
            func: function() {
              var h;
              h = new Helper(1000);
              h.go(result);
              return h;
            }
          }
        ]);
        return this.barrier.done(function(barrierResults) {
          var res;
          expect(result).toEqual([3000, 1000]);
          expect((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = barrierResults.length; j < len; j++) {
              res = barrierResults[j];
              results.push(res instanceof Helper);
            }
            return results;
          })()).toEqual([true, true]);
          return done();
        });
      });
      it("execute done-callbacks on completion and aftewards", function(done) {
        var result;
        result = [];
        this.barrier.start([
          {
            func: function() {
              return 2;
            }
          }, {
            func: function(a) {
              return a + 8;
            },
            scope: this
          }
        ]);
        return this.barrier.done((function(_this) {
          return function() {
            result.push("first");
            return _this.barrier.done(function() {
              result.push("second");
              expect(result).toEqual(["first", "second"]);
              return done();
            });
          };
        })(this));
      });
      it("set specific barrier's results (using sequences)", function(done) {
        var result;
        result = [];
        this.barrier.start([
          {
            func: function() {
              return new JSUtils.Sequence([
                {
                  func: function() {
                    var h;
                    h = new this.helperClass(1000);
                    h.go(result);
                    return {
                      done: h,
                      context: {
                        h: h
                      }
                    };
                  },
                  scope: this
                }, {
                  func: function(h) {
                    return {
                      a: 2,
                      delay: h.delay
                    };
                  }
                }
              ]);
            },
            scope: this
          }, {
            func: function() {
              return new JSUtils.Sequence([
                {
                  func: function() {
                    var h;
                    h = new this.helperClass(1001);
                    h.go(result);
                    return h;
                  },
                  scope: this
                }, {
                  func: function(h) {
                    return {
                      delay: h.delay
                    };
                  }
                }
              ]);
            },
            scope: this
          }
        ]);
        return this.barrier.done(function(barrierResults) {
          expect(barrierResults).toEqual([
            {
              a: 2,
              delay: 1000
            }, {
              delay: 1001
            }
          ]);
          return done();
        });
      });
      return it("Barrier.forArray", function(done) {
        var barrier;
        barrier = JSUtils.Barrier.forArray([1, 2, 3, 4], function(elem) {
          return elem * elem;
        });
        return barrier.done(function(barrierResults) {
          expect(barrierResults).toEqual([1, 4, 9, 16]);
          return done();
        });
      });
    });
  });

  describe("Hash", function() {
    beforeEach(function() {
      this.hash = new JSUtils.Hash();
      this.hash.put(1, "2");
      this.hash.put(2, "3");
      return this.hashEq = new JSUtils.Hash(null, 42, function(key1, key2) {
        return key1[0] + key1[1] === key2[0] + key2[1];
      });
    });
    it("get & put", function() {
      var arr, objectKey, objectVal;
      expect(this.hash.get(1)).toBe("2");
      expect(this.hash.get(["a", "b"])).toBe(void 0);
      expect(this.hash.get(2)).toBe("3");
      this.hash.put(2, "4");
      expect(this.hash.get(2)).toBe("4");
      arr = ["a", "b"];
      this.hash.put(arr, "3");
      expect(this.hash.get(arr)).toBe("3");
      expect(this.hash.get(["a", "b"])).toBeUndefined();
      objectKey = {
        key: "object"
      };
      objectVal = {
        someObject: "that's me"
      };
      this.hash.put(objectKey, objectVal);
      expect(this.hash.get(objectKey)).toBe(objectVal);
      this.hashEq.put([1, 2], 3);
      expect(this.hashEq.get([1, 2])).toBe(3);
      expect(this.hashEq.get([2, 1])).toBe(3);
      this.hashEq.put([3, 0], 3);
      expect(this.hashEq.get([3, 0])).toBe(3);
      return expect(this.hashEq.get([2, 1])).toBe(3);
    });
    it("remove", function() {
      var arr;
      arr = ["a", "b"];
      this.hash.put(arr, "3");
      this.hash.remove(1);
      expect(this.hash.get(1)).toBeUndefined();
      expect(this.hash.get(2)).toBe("3");
      this.hashEq.put([1, 2], 3);
      this.hashEq.remove([2, 1]);
      return expect(this.hashEq.get([1, 2])).toBe(42);
    });
    it("empty", function() {
      var arr;
      arr = ["a", "b"];
      this.hash.put(arr, "3");
      this.hash.empty();
      expect(this.hash.keys.length).toBe(0);
      return expect(this.hash.values.length).toBe(0);
    });
    it("items", function() {
      var arr;
      arr = ["a", "b"];
      this.hash.put(arr, "3");
      return expect(this.hash.items()).toEqual([[1, "2"], [2, "3"], [["a", "b"], "3"]]);
    });
    it("has (== hasKey)", function() {
      var arr;
      arr = ["a", "b"];
      this.hash.put(arr, "3");
      expect(this.hash.has(1)).toBe(true);
      expect(this.hash.has(2)).toBe(true);
      expect(this.hash.has(arr)).toBe(true);
      expect(this.hash.has(["a", "b"])).toBe(false);
      return expect(this.hash.has(3)).toBe(false);
    });
    it("size", function() {
      var obj;
      expect(this.hash.size()).toBe(2);
      obj = {
        a: 10,
        b: 20
      };
      this.hash.put(obj);
      expect(this.hash.size()).toBe(3);
      this.hash.put({
        x: 1e3,
        y: 0.4
      }, "value");
      expect(this.hash.size()).toBe(4);
      this.hash.remove(obj);
      return expect(this.hash.size()).toBe(3);
    });
    it("getKeys", function() {
      expect(this.hash.getKeys().length).toBe(this.hash.keys.length);
      expect(this.hash.getKeys()).toEqual(this.hash.keys);
      expect(this.hash.getKeys() === this.hash.keys).toBe(false);
      return expect(this.hash.getKeys(false) === this.hash.keys).toBe(true);
    });
    it("getValues", function() {
      expect(this.hash.getValues().length).toBe(this.hash.values.length);
      expect(this.hash.getValues()).toEqual(this.hash.values);
      expect(this.hash.getValues() === this.hash.values).toBe(false);
      return expect(this.hash.getValues(false) === this.hash.values).toBe(true);
    });
    it("getKeysForValue", function() {
      this.hash.put(3, "3");
      return expect(this.hash.getKeysForValue("3")).toEqual([2, 3]);
    });
    it("JSUtils.Hash.fromObject", function() {
      var hash;
      hash = JSUtils.Hash.fromObject({
        a: 10,
        "myKey": ["a", 22]
      });
      expect(hash.getKeys()).toEqual(["a", "myKey"]);
      return expect(hash.getValues()).toEqual([10, ["a", 22]]);
    });
    it("toObject", function() {
      var hash;
      hash = JSUtils.Hash.fromObject({
        a: 10,
        "myKey": ["a", 22]
      });
      return expect(hash.toObject()).toEqual({
        a: 10,
        myKey: ["a", 22]
      });
    });
    it("clone", function() {
      expect({
        k: this.hash.clone().getKeys(),
        v: this.hash.clone().getValues()
      }).toEqual({
        k: this.hash.getKeys(),
        v: this.hash.getValues()
      });
      return expect(this.hash.clone() === this.hash).toBe(false);
    });
    it("invert", function() {
      var inverted;
      inverted = this.hash.invert();
      expect(inverted.getKeys()).toEqual(["2", "3"]);
      return expect(inverted.getValues()).toEqual([1, 2]);
    });
    return it("each", function() {
      var maxIdx, result;
      maxIdx = null;
      this.hash.each((function(_this) {
        return function(key, val, idx) {
          expect(key).toBe(_this.hash.getKeys()[idx]);
          expect(val).toBe(_this.hash.getValues()[idx]);
          return maxIdx = idx;
        };
      })(this));
      expect(maxIdx).toBe(this.hash.size() - 1);
      result = [];
      this.hash.each(function(key, val, idx) {
        return result.push([key, val]);
      }, function(a, b) {
        return b - a;
      });
      return expect(result).toEqual([[2, "3"], [1, "2"]]);
    });
  });

  describe("overload", function() {
    beforeEach(function() {
      var A;
      this.A = (function() {
        function A() {}

        A.prototype.a = function() {
          return 1337;
        };

        return A;

      })();
      A = this.A;
      return this.TestClass = (function() {
        var e, error1;

        function TestClass() {}

        TestClass.prototype.method1 = JSUtils.overload([], [void 0, Object], [Object, void 0], function() {
          return null;
        }, [Number, String], function(a, b) {
          return a + parseInt(b, 10);
        }, [String, Number], function(a, b) {
          return parseInt(a, 10) + b;
        }, [Boolean, String], [String, Boolean], function(x, y) {
          return x + y;
        }, [A, String], function(a, b) {
          return a.a() + parseInt(b, 10);
        });

        TestClass.prototype.method2 = JSUtils.overload([Number, String], function(n, str) {
          return n + "-" + str;
        }, [Number, String, String], function(n, str1, str2) {
          return n + "-" + str1 + "+" + str2;
        });

        try {
          TestClass.prototype.method3 = JSUtils.overload([String, A], [A, Boolean]);
        } catch (error1) {
          e = error1;
          expect(e.message).toBe("No function given for argument lists: [[\"String\",\"A\"],[\"A\",\"Boolean\"]]");
        }

        return TestClass;

      })();
    });
    it("func results of overloading", function() {
      var a, testInstance;
      testInstance = new this.TestClass();
      a = new this.A();
      expect(testInstance.method1()).toBe(null);
      expect(testInstance.method1(null, 23)).toBe(null);
      expect(testInstance.method1("adsf", void 0)).toBe(null);
      expect(testInstance.method1(10, "20")).toBe(30);
      expect(testInstance.method1("20", 20)).toBe(40);
      expect(testInstance.method1(a, "20")).toBe(1357);
      expect(function() {
        return testInstance.method1(a, a);
      }).toThrow();
      expect(testInstance.method1(true, "a")).toBe("truea");
      expect(testInstance.method1("a", true)).toBe("atrue");
      expect(testInstance.method2(1, "a")).toBe("1-a");
      expect(testInstance.method2(1, "a", "b")).toBe("1-a+b");
      return expect(testInstance.method3).toBeUndefined();
    });
    return it("supports subclass checking", function() {
      var Sub, Super, f;
      Super = (function() {
        function Super() {}

        return Super;

      })();
      Sub = (function(superClass) {
        extend(Sub, superClass);

        function Sub() {
          return Sub.__super__.constructor.apply(this, arguments);
        }

        return Sub;

      })(Super);
      f = JSUtils.overload([Super], function() {
        return true;
      });
      expect(f(new Super())).toBe(true);
      expect(f(new Sub())).toBe(true);
      return expect(function() {
        return f("asdf");
      }).toThrow();
    });
  });

  describe("prototyping", function() {
    describe("nativesPrototyping", function() {
      describe("Math", function() {
        it("isNum", function() {
          expect(Math.isNum instanceof Function).toBe(true);
          expect(Math.isNum(0)).toBe(true);
          expect(Math.isNum(-2.34)).toBe(true);
          expect(Math.isNum("-2.34")).toBe(false);
          expect(Math.isNum(Infinity)).toBe(false);
          expect(Math.isNum(-Infinity)).toBe(false);
          return expect(Math.isNum(true)).toBe(false);
        });
        it("average", function() {
          expect(Math.average instanceof Function).toBe(true);
          expect(Math.average(1, 2)).toBe(1.5);
          expect(Math.average(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)).toBe(5.5);
          return expect(Math.average(-3, 2)).toBe(-0.5);
        });
        it("sign", function() {
          expect(Math.sign instanceof Function).toBe(true);
          expect(Math.sign(0)).toBe(0);
          expect(Math.sign(3)).toBe(1);
          expect(Math.sign(-3)).toBe(-1);
          expect(Math.sign("-3")).toBe(void 0);
          return expect(Math.sign(Infinity)).toBe(void 0);
        });
        return it("log10", function() {
          expect(Math.log10 instanceof Function).toBe(true);
          expect(Math.log10(1)).toBe(0);
          expect(Math.log10(10)).toBe(1);
          expect(Math.log10(100)).toBe(2);
          return expect(Math.log10(1e5)).toBe(5);
        });
      });
      describe("Function", function() {
        return it("clone", function() {
          var f1, f2, i, j, results;
          f1 = function(a) {
            return a + 2;
          };
          f2 = f1.clone();
          results = [];
          for (i = j = -100; j <= 100; i = j += 0.5) {
            results.push(expect(f1(i)).toBe(f2(i)));
          }
          return results;
        });
      });
      describe("Object", function() {
        it("except", function() {
          var a;
          a = {
            a: 10,
            b: 20,
            c: 30
          };
          return expect(Object.except(a, "b")).toEqual({
            a: 10,
            c: 30
          });
        });
        it("values", function() {
          var a;
          a = {
            a: 10,
            b: 20,
            c: 30
          };
          return expect(Object.values(a)).toEqual([10, 20, 30]);
        });
        return it("swapValues", function() {
          var a;
          a = {
            a: 10,
            b: 20,
            c: 30
          };
          return expect(Object.swapValues(a, "a", "c")).toEqual({
            a: 30,
            b: 20,
            c: 10
          });
        });
      });
      return describe("Element", function() {
        return it("remove", function() {
          var body;
          body = $(document.body);
          body.append("<div class='_test' />");
          document.querySelector("._test").remove();
          return expect(body.find("._test").length).toBe(0);
        });
      });
    });
    describe("stringPrototyping", function() {
      it("replaceMultiple", function() {
        var str;
        str = "me me me you me you bla";
        expect(str.replaceMultiple(["me", "I", "you", "you all"], 0)).toBe("I me me you all me you bla");
        expect(str.replaceMultiple(["me", "I", "you", "you all"], "tuples")).toBe("I me me you all me you bla");
        expect(str.replaceMultiple(["me", "you", "him"], 1)).toBe("him me me him me you bla");
        expect(str.replaceMultiple(["me", "you", "him"], "diffByOne")).toBe("him me me him me you bla");
        expect(str.replaceMultiple([
          "me", function(index) {
            return "" + (index + 1);
          }
        ], 2)).toBe("1 2 3 you 4 you bla");
        return expect(str.replaceMultiple([
          "me", function(index) {
            return "" + (index + 1);
          }
        ], "oneByDiff")).toBe("1 2 3 you 4 you bla");
      });
      it("firstToUpper", function() {
        return expect("manylittleletters".firstToUpper()).toBe("Manylittleletters");
      });
      it("firstToLower", function() {
        return expect("MANYBIGLETTERS".firstToLower()).toBe("mANYBIGLETTERS");
      });
      it("capitalize", function() {
        return expect("hello world, this is me".capitalize()).toBe("Hello World, This Is Me");
      });
      it("camelToKebab", function() {
        return expect("MyAwesomeClass".camelToKebab()).toBe("my-awesome-class");
      });
      it("snakeToCamel", function() {
        return expect("my_awesome_function".snakeToCamel()).toBe("myAwesomeFunction");
      });
      it("camelToSnake", function() {
        return expect("myAwesomeFunction".camelToSnake()).toBe("my_awesome_function");
      });
      it("lower & upper", function() {
        expect(String.prototype.upper).toBe(String.prototype.toUpperCase);
        return expect(String.prototype.lower).toBe(String.prototype.toLowerCase);
      });
      it("isNumeric", function() {
        expect("234".isNumeric()).toBe(true);
        expect("+234".isNumeric()).toBe(true);
        expect("-234.567".isNumeric()).toBe(true);
        expect("some string".isNumeric()).toBe(false);
        expect("10e2".isNumeric()).toBe(true);
        expect(".01".isNumeric()).toBe(true);
        return expect("NaN".isNumeric()).toBe(false);
      });
      it("endsWith", function() {
        expect("myAwesomeFunction".endsWith("Function")).toBe(true);
        return expect("myAwesomeFunction".endsWith("Wunction")).toBe(false);
      });
      it("times", function() {
        expect("word ".times(5)).toBe("word word word word word ");
        return expect("word ".times(1)).toBe("word ");
      });
      return it("encodeHTMLEntities", function() {
        return expect("Ã¼".encodeHTMLEntities()).toBe("&#252;");
      });
    });
    describe("arrayPrototyping", function() {
      it("unique", function() {
        return expect([1, 2, 2, 3, 1, 3, 4, 3, 1, 4, 3, 2].unique()).toEqual([1, 2, 3, 4]);
      });
      it("uniqueBy", function() {
        var i, objs;
        objs = (function() {
          var j, results;
          results = [];
          for (i = j = 0; j <= 10; i = ++j) {
            results.push({
              a: {
                x: [i % 3, i % 3]
              }
            });
          }
          return results;
        })();
        return expect(objs.uniqueBy(function(obj) {
          return obj.a.x;
        }, function(arr1, arr2) {
          return arr1[0] + arr1[1] === arr2[0] + arr2[1];
        })).toEqual([
          {
            a: {
              x: [0, 0]
            }
          }, {
            a: {
              x: [1, 1]
            }
          }, {
            a: {
              x: [2, 2]
            }
          }
        ]);
      });
      it("intersect & intersects", function() {
        expect([1, 2, 3, 4, 5].intersect([2, 5, 6, 7, 8])).toEqual([2, 5]);
        expect([1, 2, 3, 4, 5].intersect([6, 7, 8])).toEqual([]);
        expect([1, 2, 3, 4, 5].intersects([2, 5, 6, 7, 8])).toBe(true);
        return expect([1, 2, 3, 4, 5].intersects([6, 7, 8])).toBe(false);
      });
      it("groupBy", function() {
        var hash1, hash2, i, objs;
        objs = (function() {
          var j, results;
          results = [];
          for (i = j = 0; j < 10; i = ++j) {
            results.push({
              a: i % 3
            });
          }
          return results;
        })();
        hash1 = new JSUtils.Hash();
        hash1.put(0, [objs[0], objs[3], objs[6], objs[9]]);
        hash1.put(1, [objs[1], objs[4], objs[7]]);
        hash1.put(2, [objs[2], objs[5], objs[8]]);
        hash2 = objs.groupBy(function(o) {
          return o.a;
        });
        expect(hash1.keys).toEqual(hash2.keys);
        return expect(hash1.values).toEqual(hash2.values);
      });
      it("insert", function() {
        return expect([1, 2, 2, 3].insert(2, "a", "b")).toEqual([1, 2, "a", "b", 2, 3]);
      });
      it("remove", function() {
        expect([1, 2, 2, 3].remove(2, null, true)).toEqual([1, 3]);
        expect([1, 2, 2, 3].remove(2)).toEqual([1, 2, 3]);
        return expect([1, 2, 2, 3].remove(2, null, false)).toEqual([1, 2, 3]);
      });
      it("removeAt", function() {
        return expect([1, 2, 2, 3].removeAt(0)).toEqual([2, 2, 3]);
      });
      it("moveElem", function() {
        return expect([1, 2, 2, 3].moveElem(0, 3)).toEqual([2, 2, 3, 1]);
      });
      it("flatten", function() {
        return expect([[1, 2], [2, 3]].flatten(0)).toEqual([1, 2, 2, 3]);
      });
      it("cloneDeep", function() {
        var arr;
        arr = [1, [2, 2], 3];
        expect(arr.cloneDeep()).toEqual(arr);
        return expect(arr.cloneDeep() === arr).toBe(false);
      });
      it("except & without", function() {
        expect([1, 2, 2, 3].except(2, 3)).toEqual([1]);
        return expect([1, 2, 2, 3].without(2, 3)).toEqual([1]);
      });
      it("find", function() {
        return expect([1, [2, [2, "a"]], 3].find(function(elem) {
          return elem[1] === "a";
        })).toEqual([2, "a"]);
      });
      it("binIndexOf", function() {
        return expect([1, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10].binIndexOf(4)).toBe(4);
      });
      it("sortByProp", function() {
        var i, objs;
        objs = (function() {
          var j, results;
          results = [];
          for (i = j = 0; j < 6; i = ++j) {
            results.push({
              a: i % 3
            });
          }
          return results;
        })();
        expect(objs.sortByProp(function(o) {
          return o.a;
        })).toEqual([
          {
            a: 0
          }, {
            a: 0
          }, {
            a: 1
          }, {
            a: 1
          }, {
            a: 2
          }, {
            a: 2
          }
        ]);
        return expect(objs.sortByProp(function(o) {
          return o.a;
        }, "desc")).toEqual([
          {
            a: 2
          }, {
            a: 2
          }, {
            a: 1
          }, {
            a: 1
          }, {
            a: 0
          }, {
            a: 0
          }
        ]);
      });
      it("getMax", function() {
        var i, objs;
        objs = (function() {
          var j, results;
          results = [];
          for (i = j = 0; j < 6; i = ++j) {
            results.push({
              a: i % 3
            });
          }
          return results;
        })();
        return expect(objs.getMax(function(o) {
          return o.a;
        })).toEqual([
          {
            a: 2
          }, {
            a: 2
          }
        ]);
      });
      it("getMin", function() {
        var i, objs;
        objs = (function() {
          var j, results;
          results = [];
          for (i = j = 0; j < 6; i = ++j) {
            results.push({
              a: i % 3
            });
          }
          return results;
        })();
        return expect(objs.getMin(function(o) {
          return o.a;
        })).toEqual([
          {
            a: 0
          }, {
            a: 0
          }
        ]);
      });
      it("reverseCopy", function() {
        var arr;
        arr = [1, 2, 1, 3];
        expect(arr.reverseCopy()).toEqual([3, 1, 2, 1]);
        return expect(arr.reverseCopy() === arr).toBe(false);
      });
      it("sample", function() {
        var arr;
        arr = [1, 2, 1, 3];
        return expect(arr.sample(2).length).toBe(2);
      });
      xit("shuffle", function() {});
      it("swap", function() {
        return expect([1, 2, 2, 3].swap(1, 3)).toEqual([1, 3, 2, 2]);
      });
      it("times", function() {
        return expect([1, 2, 2, 3].times(3)).toEqual([1, 2, 2, 3, 1, 2, 2, 3, 1, 2, 2, 3]);
      });
      it("and", function() {
        return expect([1, 2, 2, 3].and(0)).toEqual([1, 2, 2, 3, 0]);
      });
      it("merge", function() {
        return expect([1, 2, 2, 3].merge([0, 8, 9])).toEqual([1, 2, 2, 3, 0, 8, 9]);
      });
      it("noNulls", function() {
        return expect([1, false, 2, 0, null, 2, null, void 0, 3].noNulls()).toEqual([1, false, 2, 0, 2, 3]);
      });
      it("getLast", function() {
        expect([1, 2, 2, 3].getLast()).toEqual([3]);
        return expect([1, 2, 2, 3].getLast(2)).toEqual([2, 3]);
      });
      it("average", function() {
        return expect([1, 2, 2, 3].average).toBe(2);
      });
      it("last", function() {
        return expect([1, 2, 2, 3].last).toBe(3);
      });
      it("sum", function() {
        return expect([1, 2, 2, 3].sum).toBe(8);
      });
      it("first", function() {
        return expect([1, 2, 2, 3].first).toBe(1);
      });
      it("second", function() {
        return expect([1, 2, 2, 3].second).toBe(2);
      });
      it("third", function() {
        return expect([1, 2, 2, 3].third).toBe(2);
      });
      it("fourth", function() {
        return expect([1, 2, 2, 3].fourth).toBe(3);
      });
      return it("aliases: prepend, append, clone (without is tested in 'expect')", function() {
        var arr;
        arr = [1, 2, 2, 3];
        expect(arr.prepend(42)).toBe(5);
        expect(arr).toEqual([42, 1, 2, 2, 3]);
        expect(arr.append(43)).toBe(6);
        expect(arr).toEqual([42, 1, 2, 2, 3, 43]);
        expect(arr.clone()).toEqual(arr);
        return expect(arr.clone() === arr).toBe(false);
      });
    });
    return describe("jQueryPrototyping", function() {
      beforeEach(function() {
        this.body = $(document.body);
        this.div = $("<div class=\"test\" />");
        return this.body.append(this.div);
      });
      afterEach(function() {
        return this.div.remove();
      });
      it("content", function() {
        var div;
        div = $("<div class=\"content\">\n    this is what we want!\n    <div>text1</div>\n    <div>text2</div>\n    <div>text3</div>\n</div>");
        this.body.append(div);
        expect(div.content()).toBe("this is what we want!");
        div.content("hello world");
        expect(div.content().trim()).toBe("hello world");
        return div.remove();
      });
      it("toggleAttr", function() {
        this.div.attr("data-test", "haha");
        this.div.toggleAttr("data-test", "state1", "state2");
        expect(this.div.attr("data-test")).toBe("state1");
        this.div.toggleAttr("data-test");
        expect(this.div.attr("data-test")).toBe("state2");
        this.div.toggleAttr("data-test");
        return expect(this.div.attr("data-test")).toBe("state1");
      });
      it("toggleCss", function() {
        this.div.toggleCss("visibility", "hidden", "visible");
        expect(this.div.css("visibility")).toBe("hidden");
        this.div.toggleCss("visibility");
        expect(this.div.css("visibility")).toBe("visible");
        this.div.toggleCss("visibility");
        return expect(this.div.css("visibility")).toBe("hidden");
      });
      it("dimensions & outerDimensions", function() {
        this.div.css({
          width: 100,
          height: 100
        });
        expect(this.div.dimensions()).toEqual({
          x: 100,
          y: 100,
          width: 100,
          height: 100
        });
        expect(this.div.outerDimensions()).toEqual({
          x: 100,
          y: 100,
          width: 100,
          height: 100
        });
        this.div.css({
          padding: 20,
          margin: 20
        });
        expect(this.div.outerDimensions(false)).toEqual({
          x: 140,
          y: 140,
          width: 140,
          height: 140
        });
        expect(this.div.outerDimensions()).toEqual({
          x: 180,
          y: 180,
          width: 180,
          height: 180
        });
        return expect(this.div.outerDimensions(true)).toEqual({
          x: 180,
          y: 180,
          width: 180,
          height: 180
        });
      });
      it("showNow", function() {
        this.div.hide(0);
        expect(this.div.is(":visible")).toBe(false);
        this.div.showNow();
        return expect(this.div.is(":visible")).toBe(true);
      });
      it("hideNow", function() {
        expect(this.div.is(":visible")).toBe(true);
        this.div.hideNow();
        return expect(this.div.is(":visible")).toBe(false);
      });
      it("inDom", function() {
        expect(this.div.inDom()).toBe(true);
        this.div.detach();
        return expect(this.div.inDom()).toBe(false);
      });
      return it("wrapAll", function() {
        this.div.wrapAll("<div class='dom' />");
        expect(this.div.parent().hasClass("dom")).toBe(true);
        this.div.parent().detach();
        this.div.wrapAll("<div class='no-dom' />");
        return expect(this.div.parent().hasClass("no-dom")).toBe(true);
      });
    });
  });

  describe("Tree", function() {
    describe("Tree", function() {
      describe("creating a tree", function() {
        it("Tree.new (== Tree.fromRecursive), defaults to Tree.newByChildRef", function() {
          var node, tree;
          tree = JSUtils.Tree["new"]({
            a: 10,
            b: 20,
            name: "root",
            children: [
              {
                a: 1,
                b: 2,
                name: "child1"
              }, {
                a: 3,
                b: 4,
                name: "child2",
                children: [
                  {
                    a: 0,
                    b: 0,
                    name: "child2-child"
                  }
                ]
              }, {
                a: 5,
                b: 6,
                name: "child3"
              }
            ]
          });
          expect(tree.data.name).toBe("root");
          expect(tree.children.length).toBe(3);
          expect((function() {
            var j, len, ref, results;
            ref = tree.children;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.data.name);
            }
            return results;
          })()).toEqual(["child1", "child2", "child3"]);
          expect(tree.children[0].data.a).toBe(1);
          return expect(tree.children[1].children[0].data.name).toBe("child2-child");
        });
        xit("Tree.newByParentRef", function() {});
        return it("magically access properties on the data object (attached to a node)", function() {
          var tree;
          tree = JSUtils.Tree["new"]({
            a: 10,
            b: 20,
            name: "root",
            children: [
              {
                a: 1,
                b: 2,
                name: "child1"
              }
            ]
          });
          expect(tree.data.name).toBe(tree.name);
          expect(tree.data.a).toBe(tree.a);
          return expect(tree.children[0].data.name).toBe(tree.children[0].name);
        });
      });
      describe("modifying a tree", function() {
        beforeEach(function() {
          return this.tree = JSUtils.Tree["new"]({
            a: 10,
            b: 20,
            name: "root",
            children: [
              {
                a: 1,
                b: 2,
                name: "child1"
              }, {
                a: 3,
                b: 4,
                name: "child2",
                children: [
                  {
                    a: 0,
                    b: 0,
                    name: "child2-child"
                  }
                ]
              }, {
                a: 5,
                b: 6,
                name: "child3"
              }
            ]
          });
        });
        it("addChild (== appendChild)", function() {
          expect(this.tree.children.length).toBe(3);
          this.tree.addChild({
            newNode: true
          });
          expect(this.tree.children.length).toBe(4);
          expect(this.tree.children[3].newNode).toBe(true);
          this.tree.addChild({
            prop: "asdf"
          }, 1);
          expect(this.tree.children.length).toBe(5);
          expect(this.tree.children[1].prop).toBe("asdf");
          return expect(this.tree.children[4].newNode).toBe(true);
        });
        it("addChildren (== appendChildren)", function() {
          expect(this.tree.children.length).toBe(3);
          this.tree.addChildren([
            {
              name: "new node 1"
            }, {
              name: "new node 2"
            }
          ], 1);
          expect(this.tree.children.length).toBe(5);
          expect(this.tree.children[1].name).toBe("new node 1");
          expect(this.tree.children[2].name).toBe("new node 2");
          expect(this.tree.children[3].name).toBe("child2");
          return expect(this.tree.children[4].name).toBe("child3");
        });
        it("setChildren", function() {
          expect(this.tree.children.length).toBe(3);
          this.tree.setChildren([
            {
              name: "new child 1"
            }, {
              name: "new child 2"
            }
          ]);
          expect(this.tree.children.length).toBe(2);
          expect(this.tree.children[0].name).toBe("new child 1");
          return expect(this.tree.children[1].name).toBe("new child 2");
        });
        it("moveTo (== appendTo)", function() {
          this.tree.children[1].children[0].moveTo(this.tree, 0);
          expect(this.tree.children[0].name).toBe("child2-child");
          expect(this.tree.children[1].children.length).toBe(0);
          return expect(this.tree.children.length).toBe(4);
        });
        it("remove", function() {
          var removed;
          removed = this.tree.children[1].remove();
          expect(this.tree.children.length).toBe(2);
          expect(this.tree.children[1].name).toBe("child3");
          return expect(removed.children[0].name).toBe("child2-child");
        });
        return it("removeChild", function() {
          this.tree.removeChild(1);
          expect(this.tree.children.length).toBe(2);
          expect(this.tree.children[1].name).toBe("child3");
          this.tree.removeChild(this.tree.children[0]);
          expect(this.tree.children.length).toBe(1);
          return expect(this.tree.children[0].name).toBe("child3");
        });
      });
      describe("traversing a tree", function() {
        beforeEach(function() {
          return this.tree = JSUtils.Tree["new"]({
            a: 10,
            b: 20,
            name: "root",
            children: [
              {
                a: 1,
                b: 2,
                name: "child1"
              }, {
                a: 3,
                b: 4,
                name: "child2",
                children: [
                  {
                    a: 0,
                    b: 0,
                    name: "child2-child"
                  }
                ]
              }, {
                a: 5,
                b: 6,
                name: "child3"
              }
            ]
          });
        });
        it("postorder (== each)", function() {
          var result;
          result = [];
          this.tree.postorder(function(node, relativeLevel, index) {
            return result.push(node.name);
          });
          expect(result).toEqual(["child1", "child2-child", "child2", "child3", "root"]);
          result = [];
          this.tree.each(function(node, relativeLevel, index) {
            return result.push(node.name);
          });
          return expect(result).toEqual(["child1", "child2-child", "child2", "child3", "root"]);
        });
        it("preorder", function() {
          var result;
          result = [];
          this.tree.preorder(function(node, relativeLevel, index) {
            return result.push(node.name);
          });
          return expect(result).toEqual(["root", "child1", "child2", "child2-child", "child3"]);
        });
        it("inorder", function() {
          var result;
          result = [];
          this.tree.inorder(function(node, relativeLevel, index) {
            return result.push(node.name);
          });
          return expect(result).toEqual(["child1", "root", "child2-child", "child2", "child3"]);
        });
        return it("levelorder", function() {
          var result;
          result = [];
          this.tree.levelorder(function(node, relativeLevel, index) {
            return result.push(node.name);
          });
          return expect(result).toEqual(["root", "child1", "child2", "child3", "child2-child"]);
        });
      });
      describe("getting information about a tree", function() {
        beforeEach(function() {
          return this.tree = JSUtils.Tree["new"]({
            a: 10,
            b: 20,
            name: "root",
            children: [
              {
                a: 1,
                b: 2,
                name: "child1"
              }, {
                a: 3,
                b: 4,
                name: "child2",
                children: [
                  {
                    a: 0,
                    b: 0,
                    name: "child2-child"
                  }
                ]
              }, {
                a: 5,
                b: 6,
                name: "child3"
              }
            ]
          });
        });
        it("depth & getDepth()", function() {
          expect(this.tree.depth).toBe(2);
          this.tree.children[1].children[0].remove();
          return expect(this.tree.depth).toBe(1);
        });
        it("size & getSize()", function() {
          return expect(this.tree.size).toBe(5);
        });
        it("level & getLevel()", function() {
          expect(this.tree.level).toBe(0);
          expect(this.tree.children[1].level).toBe(1);
          expect(this.tree.children[1].children[0].level).toBe(2);
          this.tree.children[1].children[0].addChild({
            name: "child2-child-child"
          });
          return expect(this.tree.children[1].children[0].children[0].level).toBe(3);
        });
        it("root & getRoot()", function() {
          expect(this.tree.root).toBe(this.tree);
          expect(this.tree.children[1].root).toBe(this.tree);
          return expect(this.tree.children[1].children[0].root).toBe(this.tree);
        });
        it("hasNode", function() {
          expect(this.tree.hasNode(this.tree)).toBe(true);
          expect(this.tree.hasNode(this.tree.children[0])).toBe(true);
          expect(this.tree.hasNode(this.tree.children[1])).toBe(true);
          expect(this.tree.hasNode(this.tree.children[1].children[0])).toBe(true);
          expect(this.tree.hasNode(this.tree.children[2])).toBe(true);
          return expect(this.tree.hasNode(JSUtils.Tree["new"]())).toBe(false);
        });
        it("findNode (== findDescendant)", function() {
          return expect(this.tree.findNode(function(node) {
            return node.name === "child2";
          })).toBe(this.tree.children[1]);
        });
        it("findNodes (== findDescendants)", function() {
          var names, node, nodes;
          nodes = this.tree.findNodes(function(node) {
            return node.name.length > 4;
          });
          nodes.sort(function(a, b) {
            return a - b;
          });
          names = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = nodes.length; j < len; j++) {
              node = nodes[j];
              results.push(node.name);
            }
            return results;
          })();
          return expect(names).toEqual(["child1", "child2", "child3", "child2-child"]);
        });
        it("getLeaves", function() {
          var leaf;
          return expect((function() {
            var j, len, ref, results;
            ref = this.tree.getLeaves();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              leaf = ref[j];
              results.push(leaf.name);
            }
            return results;
          }).call(this)).toEqual(["child1", "child2-child", "child3"]);
        });
        it("isLeaf", function() {
          var j, leaf, leaves, len;
          leaves = this.tree.getLeaves();
          for (j = 0, len = leaves.length; j < len; j++) {
            leaf = leaves[j];
            expect(leaf.isLeaf()).toBe(true);
          }
          return expect(this.tree.children[1].isLeaf()).toBe(false);
        });
        it("getSiblings", function() {
          var node;
          expect(this.tree.children[1].children[0].getSiblings()).toEqual([]);
          expect((function() {
            var j, len, ref, results;
            ref = this.tree.children[1].getSiblings();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.name);
            }
            return results;
          }).call(this)).toEqual(["child1", "child3"]);
          return expect(this.tree.getSiblings()).toEqual([]);
        });
        it("getLevelSiblings", function() {
          var node;
          expect((function() {
            var j, len, ref, results;
            ref = this.tree.children[1].getLevelSiblings();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.name);
            }
            return results;
          }).call(this)).toEqual(["child1", "child3"]);
          this.tree.children[0].addChild({
            name: "child1-child"
          });
          return expect(this.tree.children[0].children[0].getLevelSiblings()[0].name).toBe("child2-child");
        });
        it("getParent", function() {
          return expect(this.tree.children[0].getParent()).toBe(this.tree.children[0].parent);
        });
        it("getChildren", function() {
          return expect(this.tree.getChildren()).toBe(this.tree.children);
        });
        it("pathToRoot", function() {
          var node;
          expect((function() {
            var j, len, ref, results;
            ref = this.tree.pathToRoot();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.name);
            }
            return results;
          }).call(this)).toEqual(["root"]);
          expect((function() {
            var j, len, ref, results;
            ref = this.tree.children[0].pathToRoot();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.name);
            }
            return results;
          }).call(this)).toEqual(["child1", "root"]);
          return expect((function() {
            var j, len, ref, results;
            ref = this.tree.children[1].children[0].pathToRoot();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.name);
            }
            return results;
          }).call(this)).toEqual(["child2-child", "child2", "root"]);
        });
        it("pathFromRoot", function() {
          var node;
          expect((function() {
            var j, len, ref, results;
            ref = this.tree.pathFromRoot();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.name);
            }
            return results;
          }).call(this)).toEqual(["root"]);
          expect((function() {
            var j, len, ref, results;
            ref = this.tree.children[0].pathFromRoot();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.name);
            }
            return results;
          }).call(this)).toEqual(["root", "child1"]);
          return expect((function() {
            var j, len, ref, results;
            ref = this.tree.children[1].children[0].pathFromRoot();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.name);
            }
            return results;
          }).call(this)).toEqual(["root", "child2", "child2-child"]);
        });
        return it("closest", function() {
          expect(this.tree.closest(function() {
            return "something that doesn't matter because there is no parent anyway";
          })).toEqual(null);
          expect(this.tree.children[1].children[0].closest(function(node) {
            return node.name === "root";
          })).toEqual(this.tree);
          expect(this.tree.children[1].children[0].closest(function(node) {
            return node.name === "child2";
          })).toEqual(this.tree.children[1]);
          return expect(this.tree.children[1].children[0].closest(function(node) {
            return node.name === "child3";
          })).toEqual(null);
        });
      });
      return describe("converting a tree", function() {
        beforeEach(function() {
          return this.tree = JSUtils.Tree["new"]({
            a: 10,
            b: 20,
            name: "root",
            children: [
              {
                a: 1,
                b: 2,
                name: "child1"
              }, {
                a: 3,
                b: 4,
                name: "child2",
                children: [
                  {
                    a: 0,
                    b: 0,
                    name: "child2-child"
                  }
                ]
              }, {
                a: 5,
                b: 6,
                name: "child3"
              }
            ]
          });
        });
        it("serialize (== toObject)", function() {
          return expect(this.tree.serialize()).toEqual({
            a: 10,
            b: 20,
            name: "root",
            children: [
              {
                a: 1,
                b: 2,
                name: "child1"
              }, {
                a: 3,
                b: 4,
                name: "child2",
                children: [
                  {
                    a: 0,
                    b: 0,
                    name: "child2-child"
                  }
                ]
              }, {
                a: 5,
                b: 6,
                name: "child3"
              }
            ]
          });
        });
        return it("deserialize (a.k.a. in-place constructing)", function() {
          var child, idx, j, len, ref;
          this.tree.deserialize({
            a: 10,
            name: "new root",
            children: [
              {
                a: 1,
                name: "new child1",
                children: []
              }, {
                name: "new child2",
                children: [
                  {
                    name: "new child2-child",
                    children: []
                  }
                ]
              }
            ]
          });
          expect(this.tree.name).toBe("new root");
          ref = this.tree.children;
          for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
            child = ref[idx];
            expect(child.name).toBe("new child" + (idx + 1));
            expect(child.parent).toBe(this.tree);
          }
          expect(this.tree.children[1].children[0].name).toBe("new child2-child");
          return expect(this.tree.children[1].children[0].parent).toBe(this.tree.children[1]);
        });
      });
    });
    return describe("BinaryTree", function() {
      describe("creating a binary tree", function() {
        return it("BinaryTree.new (== BinaryTree.fromRecursive), defaults to BinaryTree.newByChildRef", function() {
          var arr, tree;
          tree = JSUtils.BinaryTree["new"]({
            n: 10,
            children: [
              {
                n: 1,
                children: [
                  {
                    n: 3
                  }
                ]
              }, {
                n: 15
              }
            ]
          }, {
            compareNodes: function(currentNode, newNode) {
              return newNode.n - currentNode.n;
            }
          });
          arr = [];
          tree.inorder(function(node) {
            arr.push(node.n);
            return true;
          });
          expect(tree.left.n).toBe(1);
          expect(tree.left.left).toEqual(null);
          expect(tree.left.right.n).toBe(3);
          return expect(tree.right.n).toBe(15);
        });
      });
      describe("modifying a tree", function() {
        beforeEach(function() {
          return this.tree = JSUtils.BinaryTree["new"]({
            n: 10,
            children: [
              {
                n: 1,
                children: [
                  {
                    n: 3
                  }
                ]
              }, {
                n: 15
              }
            ]
          }, {
            compareNodes: function(currentNode, newNode) {
              return newNode.n - currentNode.n;
            }
          });
        });
        it("addChild (== appendChild)", function() {
          this.tree.addChild({
            n: 12
          });
          return expect(this.tree.right.left.n).toBe(12);
        });
        it("addChildren (== appendChildren)", function() {
          this.tree.addChildren([
            {
              n: 12
            }, {
              n: 8
            }
          ]);
          expect(this.tree.right.left.n).toBe(12);
          return expect(this.tree.left.right.right.n).toBe(8);
        });
        it("setChildren", function() {
          return expect(this.tree.setChildren).toThrowError(/children.*cannot.*be.*set/i);
        });
        it("moveTo (== appendTo)", function() {
          expect(this.tree.moveTo).toThrowError(/cannot.*move.*node/i);
          return expect(this.tree.appendTo).toThrowError(/cannot.*move.*node/i);
        });
        it("remove", function() {
          this.tree.left.right.remove();
          return expect(this.tree.left.right).toBe(null);
        });
        return it("removeChild", function() {
          this.tree.removeChild(function(node) {
            return node.n === 1;
          });
          return expect(this.tree.left).toBe(null);
        });
      });
      describe("traversing a tree", function() {
        beforeEach(function() {
          return this.tree = JSUtils.BinaryTree["new"]({
            n: 10,
            children: [
              {
                n: 1,
                children: [
                  {
                    n: 3
                  }
                ]
              }, {
                n: 15
              }
            ]
          }, {
            compareNodes: function(currentNode, newNode) {
              return newNode.n - currentNode.n;
            }
          });
        });
        it("postorder (== each)", function() {
          var result;
          result = [];
          this.tree.postorder(function(node, relativeLevel, index) {
            return result.push(node.n);
          });
          expect(result).toEqual([3, 1, 15, 10]);
          result = [];
          this.tree.each(function(node, relativeLevel, index) {
            return result.push(node.n);
          });
          return expect(result).toEqual([3, 1, 15, 10]);
        });
        it("preorder", function() {
          var result;
          result = [];
          this.tree.preorder(function(node, relativeLevel, index) {
            return result.push(node.n);
          });
          return expect(result).toEqual([10, 1, 3, 15]);
        });
        it("inorder", function() {
          var result;
          result = [];
          this.tree.inorder(function(node, relativeLevel, index) {
            return result.push(node.n);
          });
          return expect(result).toEqual([1, 3, 10, 15]);
        });
        return it("levelorder", function() {
          var result;
          result = [];
          this.tree.levelorder(function(node, relativeLevel, index) {
            return result.push(node.n);
          });
          return expect(result).toEqual([10, 1, 15, 3]);
        });
      });
      describe("getting information about a tree", function() {
        beforeEach(function() {
          return this.tree = JSUtils.BinaryTree["new"]({
            n: 10,
            children: [
              {
                n: 1,
                children: [
                  {
                    n: 3
                  }
                ]
              }, {
                n: 15
              }
            ]
          }, {
            compareNodes: function(currentNode, newNode) {
              return newNode.n - currentNode.n;
            }
          });
        });
        it("depth & getDepth()", function() {
          return expect(this.tree.depth).toBe(2);
        });
        it("size & getSize()", function() {
          return expect(this.tree.size).toBe(4);
        });
        it("level & getLevel()", function() {
          expect(this.tree.level).toBe(0);
          expect(this.tree.left.level).toBe(1);
          return expect(this.tree.left.right.level).toBe(2);
        });
        it("root & getRoot()", function() {
          expect(this.tree.root).toBe(this.tree);
          expect(this.tree.left.root).toBe(this.tree);
          return expect(this.tree.left.right.root).toBe(this.tree);
        });
        it("hasNode", function() {
          expect(this.tree.hasNode(this.tree)).toBe(true);
          expect(this.tree.hasNode(this.tree.left)).toBe(true);
          expect(this.tree.hasNode(this.tree.right)).toBe(true);
          return expect(this.tree.hasNode(JSUtils.BinaryTree["new"]({
            n: 42
          }, function(a, b) {
            return a - b;
          }))).toBe(false);
        });
        it("findNode (== findDescendant)", function() {
          return expect(this.tree.findNode(function(node) {
            return node.n === 3;
          })).toBe(this.tree.left.right);
        });
        it("findNodes (== findDescendants)", function() {
          var node, nodes, vals;
          nodes = this.tree.findNodes(function(node) {
            return node.n > 2;
          });
          vals = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = nodes.length; j < len; j++) {
              node = nodes[j];
              results.push(node.n);
            }
            return results;
          })();
          vals.sort(function(a, b) {
            return a - b;
          });
          return expect(vals).toEqual([3, 15]);
        });
        it("getLeaves", function() {
          var leaf;
          return expect((function() {
            var j, len, ref, results;
            ref = this.tree.getLeaves();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              leaf = ref[j];
              results.push(leaf.n);
            }
            return results;
          }).call(this)).toEqual([3, 15]);
        });
        it("isLeaf", function() {
          var j, leaf, leaves, len;
          leaves = this.tree.getLeaves();
          for (j = 0, len = leaves.length; j < len; j++) {
            leaf = leaves[j];
            expect(leaf.isLeaf()).toBe(true);
          }
          return expect(this.tree.left.isLeaf()).toBe(false);
        });
        it("getSiblings", function() {
          expect(this.tree.left.getSiblings()[0].n).toBe(15);
          return expect(this.tree.getSiblings()).toEqual([]);
        });
        it("getLevelSiblings", function() {
          this.tree.addChild({
            n: 42
          });
          return expect(this.tree.left.right.getLevelSiblings()[0].n).toBe(42);
        });
        it("getParent", function() {
          return expect(this.tree.left.getParent()).toBe(this.tree.left.parent);
        });
        it("getChildren", function() {
          return expect(this.tree.getChildren()).toBe(this.tree.children);
        });
        it("pathToRoot", function() {
          var node;
          expect((function() {
            var j, len, ref, results;
            ref = this.tree.pathToRoot();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.n);
            }
            return results;
          }).call(this)).toEqual([10]);
          expect((function() {
            var j, len, ref, results;
            ref = this.tree.left.pathToRoot();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.n);
            }
            return results;
          }).call(this)).toEqual([1, 10]);
          return expect((function() {
            var j, len, ref, results;
            ref = this.tree.left.right.pathToRoot();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.n);
            }
            return results;
          }).call(this)).toEqual([3, 1, 10]);
        });
        return it("pathFromRoot", function() {
          var node;
          expect((function() {
            var j, len, ref, results;
            ref = this.tree.pathFromRoot();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.n);
            }
            return results;
          }).call(this)).toEqual([10]);
          expect((function() {
            var j, len, ref, results;
            ref = this.tree.left.pathFromRoot();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.n);
            }
            return results;
          }).call(this)).toEqual([10, 1]);
          return expect((function() {
            var j, len, ref, results;
            ref = this.tree.left.right.pathFromRoot();
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results.push(node.n);
            }
            return results;
          }).call(this)).toEqual([10, 1, 3]);
        });
      });
      describe("converting a tree", function() {
        beforeEach(function() {
          return this.tree = JSUtils.BinaryTree["new"]({
            n: 10,
            children: [
              {
                n: 1,
                children: [
                  {
                    n: 3
                  }
                ]
              }, {
                n: 15
              }
            ]
          }, {
            compareNodes: function(currentNode, newNode) {
              return newNode.n - currentNode.n;
            }
          });
        });
        it("serialize (== toObject)", function() {
          return expect(this.tree.serialize()).toEqual({
            n: 10,
            children: [
              {
                n: 1,
                children: [
                  {}, {
                    n: 3
                  }
                ]
              }, {
                n: 15
              }
            ]
          });
        });
        return it("deserialize (a.k.a. in-place constructing)", function() {
          this.tree.deserialize({
            n: 11,
            children: [
              {
                n: 2,
                children: [
                  {
                    n: 4
                  }
                ]
              }, {
                n: 16
              }
            ]
          });
          expect(this.tree.n).toBe(11);
          expect(this.tree.left.n).toBe(2);
          expect(this.tree.left.right.n).toBe(4);
          return expect(this.tree.right.n).toBe(16);
        });
      });
      return describe("balancing a tree", function() {
        return it("balance", function() {
          var tree;
          tree = JSUtils.BinaryTree["new"]({
            n: 100
          }, {
            compareNodes: function(currentNode, newNode) {
              return newNode.n - currentNode.n;
            }
          });
          tree.addChild({
            n: 90
          });
          tree.addChild({
            n: 80
          });
          tree.addChild({
            n: 70
          });
          tree.addChild({
            n: 60
          });
          tree.addChild({
            n: 50
          });
          tree.addChild({
            n: 40
          });
          tree.addChild({
            n: 30
          });
          tree.addChild({
            n: 20
          });
          tree.addChild({
            n: 10
          });
          expect(tree.depth).toBe(9);
          expect(tree.left.left.left.left.left.left.left.left.left.n).toBe(10);
          tree.balance();
          expect(tree.serialize()).toEqual({
            n: 60,
            children: [
              {
                n: 40,
                children: [
                  {
                    n: 20,
                    children: [
                      {
                        n: 10
                      }, {
                        n: 30
                      }
                    ]
                  }, {
                    n: 50
                  }
                ]
              }, {
                n: 90,
                children: [
                  {
                    n: 80
                  }, {
                    n: 100
                  }
                ]
              }
            ]
          });
          expect(tree.level).toBe(0);
          expect(tree.left.level).toBe(1);
          expect(tree.left.left.level).toBe(2);
          expect(tree.left.right.level).toBe(2);
          expect(tree.left.left.left.level).toBe(3);
          expect(tree.left.left.right.level).toBe(3);
          expect(tree.right.level).toBe(1);
          expect(tree.right.left.level).toBe(2);
          return expect(tree.right.right.level).toBe(2);
        });
      });
    });
  });

}).call(this);
